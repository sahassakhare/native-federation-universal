{"hash":"11fb77f6868fb1c1d70da9ea4ebc4a2d4726f73c","fesm2022":[{"exports":["AngularHydrationUtils","AngularUniversalFederationProvider","FederationRuntime","HydrationClient","LoadFederatedComponentDirective","ModuleLoader","NativeFederationModule","NativeFederationService","SSRFederationService","SSRFederationUtils","SSRModuleLoader","UniversalFederationRuntime","VersionManager","createSSRFederationProviders","initFederation","loadRemoteModule"],"facadeModuleId":"/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/native-federation-core.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/runtime/version-manager.mjs","/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/runtime/module-loader.mjs","/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/runtime/federation-runtime.mjs","/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/runtime/ssr-module-loader.mjs","/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/runtime/hydration-client.mjs","/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/angular/native-federation.service.mjs","/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/angular/directives/load-federated-component.directive.mjs","/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/angular/native-federation.module.mjs","/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/angular/ssr-integration.mjs","/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/types/federation.mjs","/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/public-api.mjs","/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/native-federation-core.mjs"],"name":"native-federation-core","type":"chunk","dynamicImports":[],"fileName":"native-federation-core.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["*","Injectable","Optional","Directive","Input","NgModule","inject","PLATFORM_ID","TransferState","makeStateKey","ViewContainerRef"],"semver":["*"],"@angular/common":["CommonModule","isPlatformServer","isPlatformBrowser"]},"imports":["@angular/core","semver","@angular/common"],"modules":{"/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/runtime/version-manager.mjs":{"code":"class VersionManager {\n    availableVersions = new Map();\n    installedVersions = new Map();\n    async resolveVersion(packageName, strategy = { type: 'compatible' }) {\n        const installedVersion = this.installedVersions.get(packageName);\n        const availableVersions = this.availableVersions.get(packageName) || [];\n        switch (strategy.type) {\n            case 'exact':\n                if (!installedVersion) {\n                    throw new Error(`Exact version required but ${packageName} not installed`);\n                }\n                return installedVersion;\n            case 'compatible':\n                return this.findCompatibleVersion(packageName, installedVersion, availableVersions);\n            case 'fallback':\n                try {\n                    return this.findCompatibleVersion(packageName, installedVersion, availableVersions);\n                }\n                catch {\n                    if (strategy.fallbackVersion) {\n                        return strategy.fallbackVersion;\n                    }\n                    throw new Error(`No compatible version found for ${packageName} and no fallback provided`);\n                }\n            case 'error':\n                if (!this.isVersionCompatible(installedVersion, availableVersions)) {\n                    throw new Error(`Version conflict for ${packageName}: installed ${installedVersion}, available ${availableVersions.join(', ')}`);\n                }\n                return installedVersion;\n            default:\n                throw new Error(`Unknown version strategy: ${strategy.type}`);\n        }\n    }\n    findCompatibleVersion(packageName, installedVersion, availableVersions = []) {\n        if (!installedVersion) {\n            if (availableVersions.length > 0) {\n                return availableVersions[0];\n            }\n            throw new Error(`No version available for ${packageName}`);\n        }\n        if (availableVersions.length === 0) {\n            return installedVersion;\n        }\n        const compatibleVersions = availableVersions.filter(version => this.areVersionsCompatible(installedVersion, version));\n        if (compatibleVersions.length === 0) {\n            throw new Error(`No compatible version found for ${packageName}. Installed: ${installedVersion}, Available: ${availableVersions.join(', ')}`);\n        }\n        return this.selectBestVersion(compatibleVersions);\n    }\n    areVersionsCompatible(version1, version2) {\n        try {\n            const range1 = semver.major(version1);\n            const range2 = semver.major(version2);\n            return range1 === range2;\n        }\n        catch {\n            return version1 === version2;\n        }\n    }\n    isVersionCompatible(installedVersion, availableVersions = []) {\n        if (!installedVersion || availableVersions.length === 0) {\n            return true;\n        }\n        return availableVersions.some(version => this.areVersionsCompatible(installedVersion, version));\n    }\n    selectBestVersion(versions) {\n        try {\n            return semver.rsort(versions)[0];\n        }\n        catch {\n            return versions[0];\n        }\n    }\n    registerInstalledVersion(packageName, version) {\n        this.installedVersions.set(packageName, version);\n    }\n    registerAvailableVersions(packageName, versions) {\n        this.availableVersions.set(packageName, versions);\n    }\n    getInstalledVersion(packageName) {\n        return this.installedVersions.get(packageName);\n    }\n    getAvailableVersions(packageName) {\n        return this.availableVersions.get(packageName) || [];\n    }\n    validateVersionConstraint(packageName, constraint) {\n        const installedVersion = this.installedVersions.get(packageName);\n        if (!installedVersion) {\n            return false;\n        }\n        try {\n            return semver.satisfies(installedVersion, constraint);\n        }\n        catch {\n            return installedVersion === constraint;\n        }\n    }\n    clear() {\n        this.availableVersions.clear();\n        this.installedVersions.clear();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: VersionManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: VersionManager, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: VersionManager, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });","originalLength":15508,"removedExports":[],"renderedExports":["VersionManager"],"renderedLength":4631},"/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/runtime/module-loader.mjs":{"code":"class ModuleLoader {\n    versionManager;\n    loadedModules = new Map();\n    manifest = {};\n    importMapElement;\n    constructor(versionManager) {\n        this.versionManager = versionManager;\n    }\n    async initialize(manifestPath) {\n        if (manifestPath) {\n            this.manifest = await this.loadManifest(manifestPath);\n        }\n        await this.setupImportMaps();\n    }\n    async loadRemoteModule(remoteName, modulePath) {\n        const moduleId = `${remoteName}${modulePath}`;\n        if (this.loadedModules.has(moduleId)) {\n            const moduleInfo = this.loadedModules.get(moduleId);\n            if (moduleInfo.loaded) {\n                return import(moduleInfo.url);\n            }\n        }\n        const remoteUrl = await this.resolveRemoteUrl(remoteName);\n        const moduleUrl = await this.resolveModuleUrl(remoteUrl, modulePath);\n        try {\n            const module = await this.loadModule(moduleUrl);\n            this.loadedModules.set(moduleId, {\n                id: moduleId,\n                name: remoteName,\n                version: '1.0.0',\n                url: moduleUrl,\n                deps: [],\n                loaded: true,\n                singleton: false\n            });\n            return module;\n        }\n        catch (error) {\n            throw new Error(`Failed to load remote module ${remoteName}${modulePath}: ${error.message}`);\n        }\n    }\n    async loadSharedModule(packageName, versionStrategy) {\n        const moduleInfo = this.loadedModules.get(packageName);\n        if (moduleInfo?.singleton && moduleInfo.loaded) {\n            return import(moduleInfo.url);\n        }\n        const resolvedVersion = await this.versionManager.resolveVersion(packageName, versionStrategy);\n        const moduleUrl = await this.resolveSharedModuleUrl(packageName, resolvedVersion);\n        try {\n            const module = await this.loadModule(moduleUrl);\n            this.loadedModules.set(packageName, {\n                id: packageName,\n                name: packageName,\n                version: resolvedVersion,\n                url: moduleUrl,\n                deps: [],\n                loaded: true,\n                singleton: true\n            });\n            return module;\n        }\n        catch (error) {\n            if (versionStrategy?.type === 'fallback' && versionStrategy.fallbackVersion) {\n                return this.loadSharedModule(packageName, {\n                    type: 'exact',\n                });\n            }\n            throw new Error(`Failed to load shared module ${packageName}: ${error.message}`);\n        }\n    }\n    async loadManifest(manifestPath) {\n        try {\n            const response = await fetch(manifestPath);\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            return await response.json();\n        }\n        catch (error) {\n            console.warn(`[Native Federation] Failed to load manifest from ${manifestPath}:`, error.message);\n            return {};\n        }\n    }\n    async setupImportMaps() {\n        try {\n            const importMapResponse = await fetch('./importmap.json');\n            if (importMapResponse.ok) {\n                const importMap = await importMapResponse.json();\n                this.injectImportMap(importMap);\n            }\n        }\n        catch (error) {\n            console.warn('[Native Federation] Failed to load import map:', error.message);\n        }\n    }\n    injectImportMap(importMap) {\n        if (this.importMapElement) {\n            this.importMapElement.remove();\n        }\n        this.importMapElement = document.createElement('script');\n        this.importMapElement.type = 'importmap';\n        this.importMapElement.textContent = JSON.stringify(importMap);\n        document.head.appendChild(this.importMapElement);\n    }\n    async resolveRemoteUrl(remoteName) {\n        if (this.manifest[remoteName]) {\n            return this.manifest[remoteName];\n        }\n        throw new Error(`Remote ${remoteName} not found in manifest`);\n    }\n    async resolveModuleUrl(remoteUrl, modulePath) {\n        try {\n            const response = await fetch(remoteUrl);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch remote entry: HTTP ${response.status}`);\n            }\n            const remoteEntry = await response.json();\n            if (!remoteEntry.metadata?.exposes?.[modulePath]) {\n                throw new Error(`Module ${modulePath} not exposed by remote`);\n            }\n            const baseUrl = new URL(remoteUrl).origin;\n            const exposedPath = remoteEntry.metadata.exposes[modulePath];\n            return new URL(exposedPath, baseUrl).href;\n        }\n        catch (error) {\n            throw new Error(`Failed to resolve module URL: ${error.message}`);\n        }\n    }\n    async resolveSharedModuleUrl(packageName, version) {\n        const baseUrl = window.location.origin;\n        return `${baseUrl}/node_modules/.cache/native-federation/esm-packages/${packageName}/index.mjs`;\n    }\n    async loadModule(url) {\n        try {\n            return await import(url);\n        }\n        catch (error) {\n            throw new Error(`Module import failed: ${error.message}`);\n        }\n    }\n    getLoadedModules() {\n        return new Map(this.loadedModules);\n    }\n    async preloadModule(remoteName, modulePath) {\n        const link = document.createElement('link');\n        link.rel = 'modulepreload';\n        link.href = await this.resolveModuleUrl(await this.resolveRemoteUrl(remoteName), modulePath);\n        document.head.appendChild(link);\n    }\n    clearCache() {\n        this.loadedModules.clear();\n        if (this.importMapElement) {\n            this.importMapElement.remove();\n            this.importMapElement = undefined;\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: ModuleLoader, deps: [{ token: VersionManager }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: ModuleLoader, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: ModuleLoader, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: VersionManager }] });","originalLength":22250,"removedExports":[],"renderedExports":["ModuleLoader"],"renderedLength":6464},"/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/runtime/federation-runtime.mjs":{"code":"class FederationRuntime {\n    moduleLoader;\n    initialized = false;\n    manifest = null;\n    constructor(moduleLoader) {\n        this.moduleLoader = moduleLoader;\n    }\n    async initialize(manifestPath) {\n        if (this.initialized) {\n            console.warn('[Native Federation] Federation already initialized');\n            return;\n        }\n        try {\n            await this.moduleLoader.initialize(manifestPath);\n            this.initialized = true;\n            if (typeof window !== 'undefined') {\n                window.__nativeFederation = {\n                    loadRemoteModule: this.loadRemoteModule.bind(this),\n                    loadSharedModule: this.loadSharedModule.bind(this),\n                    preloadModule: this.preloadModule.bind(this),\n                    getLoadedModules: this.getLoadedModules.bind(this),\n                    clearCache: this.clearCache.bind(this)\n                };\n            }\n            console.log('[Native Federation] Federation initialized successfully');\n        }\n        catch (error) {\n            console.error('[Native Federation] Failed to initialize federation:', error);\n            throw error;\n        }\n    }\n    async loadRemoteModule(remoteName, modulePath) {\n        if (!this.initialized) {\n            throw new Error('[Native Federation] Federation not initialized. Call initialize() first.');\n        }\n        return this.moduleLoader.loadRemoteModule(remoteName, modulePath);\n    }\n    async loadSharedModule(packageName) {\n        if (!this.initialized) {\n            throw new Error('[Native Federation] Federation not initialized. Call initialize() first.');\n        }\n        return this.moduleLoader.loadSharedModule(packageName);\n    }\n    async preloadModule(remoteName, modulePath) {\n        if (!this.initialized) {\n            throw new Error('[Native Federation] Federation not initialized. Call initialize() first.');\n        }\n        return this.moduleLoader.preloadModule(remoteName, modulePath);\n    }\n    getLoadedModules() {\n        if (!this.initialized) {\n            return new Map();\n        }\n        return this.moduleLoader.getLoadedModules();\n    }\n    clearCache() {\n        this.moduleLoader.clearCache();\n    }\n    isInitialized() {\n        return this.initialized;\n    }\n    async reinitialize(manifestPath) {\n        this.moduleLoader.clearCache();\n        this.initialized = false;\n        await this.initialize(manifestPath);\n    }\n    getFederationStatus() {\n        return {\n            initialized: this.initialized,\n            loadedModulesCount: this.moduleLoader.getLoadedModules().size,\n            hasModuleLoader: true\n        };\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: FederationRuntime, deps: [{ token: ModuleLoader }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: FederationRuntime, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: FederationRuntime, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: ModuleLoader }] });\n// Export functions for backward compatibility\nasync function initFederation(manifestPath) {\n    // Deprecated - use FederationRuntime class instead\n    console.warn('[Native Federation] initFederation() is deprecated. Use FederationRuntime class instead.');\n}\nasync function loadRemoteModule(remoteName, modulePath) {\n    // Deprecated - use FederationRuntime class instead\n    throw new Error('[Native Federation] loadRemoteModule() is deprecated. Use FederationRuntime class instead.');\n}","originalLength":12304,"removedExports":[],"renderedExports":["FederationRuntime","initFederation","loadRemoteModule"],"renderedLength":3798},"/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/runtime/ssr-module-loader.mjs":{"code":"/**\n * Server-side module loader for SSR environments\n * Handles module federation during server-side rendering\n */\nclass SSRModuleLoader {\n    versionManager;\n    loadedModules = new Map();\n    manifest = {};\n    moduleCache = new Map();\n    manifestPath;\n    ssrContext;\n    constructor(versionManager, ssrContext) {\n        this.versionManager = versionManager;\n        this.manifestPath = ssrContext?.manifestPath;\n        this.ssrContext = ssrContext;\n    }\n    async initialize() {\n        if (this.manifestPath) {\n            this.manifest = await this.loadManifest(this.manifestPath);\n        }\n    }\n    /**\n     * Load remote module during SSR\n     * Returns pre-rendered content and hydration instructions\n     */\n    async loadRemoteModule(remoteName, modulePath) {\n        const moduleId = `${remoteName}${modulePath}`;\n        // Check cache first\n        if (this.moduleCache.has(moduleId)) {\n            return { module: this.moduleCache.get(moduleId) };\n        }\n        try {\n            // In SSR, we need to resolve module path differently\n            const moduleUrl = await this.resolveSSRModuleUrl(remoteName, modulePath);\n            const module = await this.loadSSRModule(moduleUrl);\n            // Cache the module\n            this.moduleCache.set(moduleId, module);\n            this.loadedModules.set(moduleId, {\n                id: moduleId,\n                name: remoteName,\n                version: '1.0.0',\n                url: moduleUrl,\n                deps: [],\n                loaded: true,\n                singleton: false\n            });\n            // Extract SSR content if available\n            let ssrContent;\n            let hydrationData;\n            if (module.renderToString && typeof module.renderToString === 'function') {\n                ssrContent = await module.renderToString();\n            }\n            if (module.getHydrationData && typeof module.getHydrationData === 'function') {\n                hydrationData = await module.getHydrationData();\n            }\n            return { module, ssrContent, hydrationData };\n        }\n        catch (error) {\n            // In SSR, we might want to return fallback content instead of throwing\n            console.warn(`[SSR] Failed to load remote module ${remoteName}${modulePath}:`, error.message);\n            return {\n                module: this.createFallbackModule(remoteName, modulePath),\n                ssrContent: `<!-- SSR: Failed to load ${remoteName}${modulePath} -->`,\n                hydrationData: { fallback: true, remoteName, modulePath }\n            };\n        }\n    }\n    /**\n     * Load shared module during SSR\n     */\n    async loadSharedModule(packageName, versionStrategy) {\n        const moduleInfo = this.loadedModules.get(packageName);\n        if (moduleInfo?.singleton && moduleInfo.loaded && this.moduleCache.has(packageName)) {\n            return this.moduleCache.get(packageName);\n        }\n        try {\n            // In Node.js environment, we can use require\n            const module = this.ssrContext?.require\n                ? this.ssrContext.require(packageName)\n                : await import(packageName);\n            this.moduleCache.set(packageName, module);\n            this.loadedModules.set(packageName, {\n                id: packageName,\n                name: packageName,\n                version: '1.0.0', // We'd need to resolve this properly\n                url: packageName,\n                deps: [],\n                loaded: true,\n                singleton: true\n            });\n            return module;\n        }\n        catch (error) {\n            throw new Error(`Failed to load shared module ${packageName} in SSR: ${error.message}`);\n        }\n    }\n    /**\n     * Generate hydration manifest for client-side\n     */\n    generateHydrationManifest() {\n        const loadedModules = [];\n        this.loadedModules.forEach((moduleInfo) => {\n            loadedModules.push({\n                id: moduleInfo.id,\n                name: moduleInfo.name,\n                url: moduleInfo.url,\n                hydrationData: moduleInfo.hydrationData\n            });\n        });\n        return {\n            loadedModules,\n            importMap: this.generateImportMap()\n        };\n    }\n    async loadManifest(manifestPath) {\n        try {\n            const fetchFn = this.ssrContext?.fetch || fetch;\n            const response = await fetchFn(manifestPath);\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            return await response.json();\n        }\n        catch (error) {\n            console.warn(`[SSR] Failed to load manifest from ${manifestPath}:`, error.message);\n            return {};\n        }\n    }\n    async resolveSSRModuleUrl(remoteName, modulePath) {\n        // In SSR, we might need to resolve to local file paths or URLs\n        if (this.manifest[remoteName]) {\n            const remoteUrl = this.manifest[remoteName];\n            // Handle local file paths for SSR\n            if (remoteUrl.startsWith('/') || remoteUrl.startsWith('./')) {\n                return `${remoteUrl}${modulePath}`;\n            }\n            // Handle remote URLs\n            return `${remoteUrl}${modulePath}`;\n        }\n        throw new Error(`Remote ${remoteName} not found in SSR manifest`);\n    }\n    async loadSSRModule(url) {\n        try {\n            // In Node.js environment, handle different module loading strategies\n            if (url.startsWith('http')) {\n                // Remote module - might need special handling\n                const fetchFn = this.ssrContext?.fetch || fetch;\n                const response = await fetchFn(url);\n                const moduleCode = await response.text();\n                // In production SSR, you'd want to evaluate this safely\n                // For now, we'll simulate a module structure\n                return { default: null, __ssrModule: true };\n            }\n            else {\n                // Local module\n                return this.ssrContext?.require\n                    ? this.ssrContext.require(url)\n                    : await import(url);\n            }\n        }\n        catch (error) {\n            throw new Error(`SSR module import failed: ${error.message}`);\n        }\n    }\n    createFallbackModule(remoteName, modulePath) {\n        return {\n            default: null,\n            __fallback: true,\n            __remoteName: remoteName,\n            __modulePath: modulePath,\n            renderToString: () => `<!-- Fallback for ${remoteName}${modulePath} -->`,\n            getHydrationData: () => ({ fallback: true })\n        };\n    }\n    generateImportMap() {\n        const importMap = {};\n        this.loadedModules.forEach((moduleInfo) => {\n            if (moduleInfo.name.startsWith('@') || !moduleInfo.name.includes('/')) {\n                // Shared dependency\n                importMap[moduleInfo.name] = moduleInfo.url;\n            }\n        });\n        return importMap;\n    }\n    getLoadedModules() {\n        return new Map(this.loadedModules);\n    }\n    clearCache() {\n        this.loadedModules.clear();\n        this.moduleCache.clear();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: SSRModuleLoader, deps: \"invalid\", target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: SSRModuleLoader, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: SSRModuleLoader, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: VersionManager }, { type: undefined, decorators: [{\n                    type: Optional\n                }] }] });\n/**\n * SSR utilities for framework integration\n */\nclass SSRFederationUtils {\n    static injectHydrationScript(html, hydrationManifest) {\n        const script = `\n      <script type=\"module\">\n        // Hydration data for Native Federation\n        window.__NF_HYDRATION__ = ${JSON.stringify(hydrationManifest)};\n        \n        // Pre-populate module cache\n        if (window.__NF_HYDRATION__.loadedModules) {\n          window.__NF_LOADED_MODULES__ = new Map();\n          window.__NF_HYDRATION__.loadedModules.forEach(mod => {\n            window.__NF_LOADED_MODULES__.set(mod.id, mod);\n          });\n        }\n      </script>\n    `;\n        // Inject before closing head tag\n        return html.replace('</head>', `${script}</head>`);\n    }\n    static generatePreloadLinks(loadedModules) {\n        return loadedModules\n            .map(mod => `<link rel=\"modulepreload\" href=\"${mod.url}\">`)\n            .join('\\n');\n    }\n}","originalLength":29373,"removedExports":[],"renderedExports":["SSRModuleLoader","SSRFederationUtils"],"renderedLength":8805},"/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/runtime/hydration-client.mjs":{"code":"/**\n * Client-side hydration support for SSR\n * Resumes federation state from server-rendered content\n */\nclass HydrationClient extends ModuleLoader {\n    hydrationData;\n    ssrModuleCache = new Map();\n    constructor(versionManager) {\n        super(versionManager);\n    }\n    async initializeWithHydration(manifestPath) {\n        // Extract hydration data from SSR\n        this.extractHydrationData();\n        // Initialize base module loader\n        await this.initialize(manifestPath);\n        // Restore SSR module cache\n        await this.restoreSSRModules();\n    }\n    /**\n     * Load remote module with hydration support\n     * Checks SSR cache first, then falls back to normal loading\n     */\n    async loadRemoteModule(remoteName, modulePath) {\n        const moduleId = `${remoteName}${modulePath}`;\n        // Check if module was loaded during SSR\n        if (this.ssrModuleCache.has(moduleId)) {\n            const cached = this.ssrModuleCache.get(moduleId);\n            // If it's a fallback, try to load the real module\n            if (cached.__fallback) {\n                try {\n                    return await super.loadRemoteModule(remoteName, modulePath);\n                }\n                catch (error) {\n                    console.warn(`[Hydration] Failed to load real module, using fallback:`, error);\n                    return cached;\n                }\n            }\n            return cached;\n        }\n        // Fall back to normal loading\n        return super.loadRemoteModule(remoteName, modulePath);\n    }\n    /**\n     * Check if module was server-rendered\n     */\n    wasServerRendered(remoteName, modulePath) {\n        const moduleId = `${remoteName}${modulePath}`;\n        return this.ssrModuleCache.has(moduleId);\n    }\n    /**\n     * Get hydration data for a specific module\n     */\n    getModuleHydrationData(remoteName, modulePath) {\n        const moduleId = `${remoteName}${modulePath}`;\n        const cached = this.ssrModuleCache.get(moduleId);\n        return cached?.hydrationData;\n    }\n    extractHydrationData() {\n        // Extract hydration data injected by SSR\n        const hydrationData = window.__NF_HYDRATION__;\n        const loadedModules = window.__NF_LOADED_MODULES__;\n        if (hydrationData) {\n            this.hydrationData = hydrationData;\n            // Restore import map if available\n            if (hydrationData.importMap) {\n                this.injectHydrationImportMap({ imports: hydrationData.importMap });\n            }\n        }\n        if (loadedModules) {\n            loadedModules.forEach((moduleInfo, moduleId) => {\n                this.ssrModuleCache.set(moduleId, {\n                    ...moduleInfo,\n                    __fromSSR: true\n                });\n            });\n        }\n    }\n    async restoreSSRModules() {\n        if (!this.hydrationData?.loadedModules) {\n            return;\n        }\n        // Process each module that was loaded during SSR\n        for (const moduleInfo of this.hydrationData.loadedModules) {\n            try {\n                // For non-fallback modules, try to establish client-side reference\n                if (!moduleInfo.hydrationData?.fallback) {\n                    const module = await import(moduleInfo.url);\n                    this.ssrModuleCache.set(moduleInfo.id, module);\n                }\n            }\n            catch (error) {\n                console.warn(`[Hydration] Could not restore module ${moduleInfo.id}:`, error);\n            }\n        }\n    }\n    injectHydrationImportMap(importMap) {\n        const existingScript = document.querySelector('script[type=\"importmap\"]');\n        if (existingScript) {\n            // Merge with existing import map\n            const existing = JSON.parse(existingScript.textContent || '{}');\n            const merged = {\n                imports: {\n                    ...existing.imports,\n                    ...importMap.imports\n                }\n            };\n            existingScript.textContent = JSON.stringify(merged);\n        }\n        else {\n            // Create new import map\n            const script = document.createElement('script');\n            script.type = 'importmap';\n            script.textContent = JSON.stringify(importMap);\n            document.head.appendChild(script);\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: HydrationClient, deps: [{ token: VersionManager }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: HydrationClient, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: HydrationClient, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: VersionManager }] });\n/**\n * Angular-specific hydration utilities\n */\nclass AngularHydrationUtils {\n    /**\n     * Initialize Native Federation with Angular Universal hydration\n     */\n    static async initializeForAngularSSR(client, manifestPath) {\n        await client.initializeWithHydration(manifestPath);\n        // Wait for Angular hydration to complete before loading remote modules\n        if (window.ng && window.ng.getInjector) {\n            await this.waitForAngularHydration();\n        }\n        return client;\n    }\n    /**\n     * Wait for Angular hydration to complete\n     */\n    static async waitForAngularHydration() {\n        return new Promise((resolve) => {\n            const checkHydration = () => {\n                const appRef = window.ng?.getInjector?.()?.get?.('ApplicationRef');\n                if (appRef && appRef.isStable) {\n                    appRef.isStable.subscribe((stable) => {\n                        if (stable) {\n                            resolve();\n                        }\n                    });\n                }\n                else {\n                    // Fallback: wait a bit and try again\n                    setTimeout(checkHydration, 100);\n                }\n            };\n            checkHydration();\n        });\n    }\n    /**\n     * Create Angular component wrapper that handles SSR/hydration\n     */\n    static createSSRComponent(loader, fallbackTemplate = '<div>Loading...</div>') {\n        return {\n            template: fallbackTemplate,\n            async ngOnInit() {\n                try {\n                    const { default: Component } = await loader();\n                    // Dynamic component loading logic would go here\n                    // This would integrate with Angular's ViewContainerRef\n                }\n                catch (error) {\n                    console.error('Failed to load federated component:', error);\n                }\n            }\n        };\n    }\n}\n/**\n * Universal federation runtime that works in both SSR and client\n */\nclass UniversalFederationRuntime {\n    hydrationClient;\n    isSSR;\n    constructor(hydrationClient) {\n        this.hydrationClient = hydrationClient;\n        this.isSSR = typeof window === 'undefined';\n    }\n    async initialize(manifestPath) {\n        if (this.isSSR) {\n            // SSR initialization will be handled separately\n            return;\n        }\n        await this.hydrationClient.initializeWithHydration(manifestPath);\n    }\n    async loadRemoteModule(remoteName, modulePath) {\n        if (this.isSSR) {\n            throw new Error('SSR module loading should use SSRModuleLoader directly');\n        }\n        return this.hydrationClient.loadRemoteModule(remoteName, modulePath);\n    }\n    async loadSharedModule(packageName) {\n        return this.hydrationClient.loadSharedModule(packageName);\n    }\n    wasServerRendered(remoteName, modulePath) {\n        if (this.isSSR) {\n            return false;\n        }\n        return this.hydrationClient.wasServerRendered(remoteName, modulePath);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: UniversalFederationRuntime, deps: [{ token: HydrationClient }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: UniversalFederationRuntime, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: UniversalFederationRuntime, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: HydrationClient }] });","originalLength":26358,"removedExports":[],"renderedExports":["HydrationClient","AngularHydrationUtils","UniversalFederationRuntime"],"renderedLength":8614},"/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/angular/native-federation.service.mjs":{"code":"class NativeFederationService {\n    runtime;\n    moduleLoader;\n    constructor(runtime, moduleLoader) {\n        this.runtime = runtime;\n        this.moduleLoader = moduleLoader;\n    }\n    /**\n     * Initialize the federation runtime with a manifest\n     */\n    async initialize(manifestUrl) {\n        await this.runtime.initialize(manifestUrl);\n    }\n    /**\n     * Load a remote module dynamically\n     */\n    async loadRemoteModule(remoteName, modulePath) {\n        return this.moduleLoader.loadRemoteModule(remoteName, modulePath);\n    }\n    /**\n     * Check if a module is loaded\n     */\n    isModuleLoaded(remoteName, modulePath) {\n        const moduleId = `${remoteName}${modulePath}`;\n        return this.moduleLoader.getLoadedModules().has(moduleId);\n    }\n    /**\n     * Preload a remote module\n     */\n    async preloadModule(remoteName, modulePath) {\n        await this.moduleLoader.preloadModule(remoteName, modulePath);\n    }\n    /**\n     * Get the runtime instance for advanced usage\n     */\n    getRuntime() {\n        return this.runtime;\n    }\n    /**\n     * Get the module loader instance for advanced usage\n     */\n    getModuleLoader() {\n        return this.moduleLoader;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationService, deps: [{ token: FederationRuntime }, { token: ModuleLoader }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationService, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: FederationRuntime }, { type: ModuleLoader }] });","originalLength":5941,"removedExports":[],"renderedExports":["NativeFederationService"],"renderedLength":1921},"/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/angular/directives/load-federated-component.directive.mjs":{"code":"let LoadFederatedComponentDirective$1 = class LoadFederatedComponentDirective {\n    viewContainer;\n    federationService;\n    cdr;\n    injector;\n    componentInfo;\n    fallbackTemplate;\n    loadingTemplate;\n    errorTemplate;\n    inputs;\n    componentRef;\n    currentView;\n    isLoading = false;\n    constructor(viewContainer, federationService, cdr, injector) {\n        this.viewContainer = viewContainer;\n        this.federationService = federationService;\n        this.cdr = cdr;\n        this.injector = injector;\n    }\n    async ngOnInit() {\n        await this.loadComponent();\n    }\n    ngOnDestroy() {\n        this.cleanup();\n    }\n    async loadComponent() {\n        if (!this.componentInfo) {\n            console.warn('[LoadFederatedComponentDirective] No component info provided');\n            return;\n        }\n        // Parse component info (format: \"remoteName/modulePath\")\n        const [remoteName, modulePath] = this.componentInfo.split('/');\n        if (!remoteName || !modulePath) {\n            console.error('[LoadFederatedComponentDirective] Invalid component info format. Use \"remoteName/modulePath\"');\n            this.showErrorView('Invalid component format');\n            return;\n        }\n        try {\n            this.isLoading = true;\n            this.showLoadingView();\n            // Load the remote module\n            const module = await this.federationService.loadRemoteModule(remoteName, `./${modulePath}`);\n            // Get the component from the module\n            const ComponentClass = this.getComponentFromModule(module);\n            if (!ComponentClass) {\n                throw new Error(`Component not found in module ${remoteName}/${modulePath}`);\n            }\n            // Create and insert the component\n            await this.createComponent(ComponentClass);\n        }\n        catch (error) {\n            console.error('[LoadFederatedComponentDirective] Failed to load component:', error);\n            this.showErrorView(error instanceof Error ? error.message : 'Unknown error');\n        }\n        finally {\n            this.isLoading = false;\n        }\n    }\n    getComponentFromModule(module) {\n        // Try different common export patterns\n        if (module.default && typeof module.default === 'function') {\n            return module.default;\n        }\n        if (module.Component && typeof module.Component === 'function') {\n            return module.Component;\n        }\n        // Look for the first function export (likely a component)\n        for (const key of Object.keys(module)) {\n            if (typeof module[key] === 'function' && key !== 'default') {\n                return module[key];\n            }\n        }\n        return null;\n    }\n    async createComponent(ComponentClass) {\n        this.cleanup();\n        try {\n            // Create the component\n            this.componentRef = this.viewContainer.createComponent(ComponentClass, {\n                injector: this.injector\n            });\n            // Set inputs if provided\n            if (this.inputs) {\n                Object.keys(this.inputs).forEach(key => {\n                    if (this.componentRef?.instance[key] !== undefined) {\n                        this.componentRef.instance[key] = this.inputs[key];\n                    }\n                });\n            }\n            // Trigger change detection\n            this.componentRef.changeDetectorRef.detectChanges();\n            this.cdr.detectChanges();\n        }\n        catch (error) {\n            console.error('[LoadFederatedComponentDirective] Failed to create component:', error);\n            throw error;\n        }\n    }\n    showLoadingView() {\n        this.cleanup();\n        if (this.loadingTemplate) {\n            this.currentView = this.viewContainer.createEmbeddedView(this.loadingTemplate);\n        }\n        else {\n            // Create default loading view\n            this.createDefaultLoadingView();\n        }\n    }\n    showErrorView(error) {\n        this.cleanup();\n        if (this.errorTemplate) {\n            this.currentView = this.viewContainer.createEmbeddedView(this.errorTemplate, { error });\n        }\n        else if (this.fallbackTemplate) {\n            this.currentView = this.viewContainer.createEmbeddedView(this.fallbackTemplate);\n        }\n        else {\n            // Create default error view\n            this.createDefaultErrorView(error);\n        }\n    }\n    createDefaultLoadingView() {\n        const div = document.createElement('div');\n        div.style.padding = '20px';\n        div.style.textAlign = 'center';\n        div.style.color = '#666';\n        div.innerHTML = '⏳ Loading federated component...';\n        const elementRef = { nativeElement: div };\n        this.currentView = this.viewContainer.createEmbeddedView({ createEmbeddedView: () => ({ rootNodes: [div] }) });\n    }\n    createDefaultErrorView(error) {\n        const div = document.createElement('div');\n        div.style.padding = '20px';\n        div.style.border = '1px solid #f5c6cb';\n        div.style.backgroundColor = '#f8d7da';\n        div.style.color = '#721c24';\n        div.style.borderRadius = '4px';\n        div.innerHTML = `\n      <strong>❌ Failed to load federated component</strong><br>\n      <small>${this.componentInfo}</small><br>\n      <em>${error}</em>\n    `;\n        this.currentView = this.viewContainer.createEmbeddedView({ createEmbeddedView: () => ({ rootNodes: [div] }) });\n    }\n    cleanup() {\n        if (this.componentRef) {\n            this.componentRef.destroy();\n            this.componentRef = undefined;\n        }\n        if (this.currentView) {\n            this.currentView.destroy();\n            this.currentView = undefined;\n        }\n        this.viewContainer.clear();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: LoadFederatedComponentDirective, deps: [{ token: i0.ViewContainerRef }, { token: NativeFederationService }, { token: i0.ChangeDetectorRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.2.13\", type: LoadFederatedComponentDirective, selector: \"[nfLoadComponent]\", inputs: { componentInfo: [\"nfLoadComponent\", \"componentInfo\"], fallbackTemplate: [\"nfFallback\", \"fallbackTemplate\"], loadingTemplate: [\"nfLoadingTemplate\", \"loadingTemplate\"], errorTemplate: [\"nfErrorTemplate\", \"errorTemplate\"], inputs: [\"nfInputs\", \"inputs\"] }, ngImport: i0 });\n};\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: LoadFederatedComponentDirective$1, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[nfLoadComponent]'\n                }]\n        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: NativeFederationService }, { type: i0.ChangeDetectorRef }, { type: i0.Injector }], propDecorators: { componentInfo: [{\n                type: Input,\n                args: ['nfLoadComponent']\n            }], fallbackTemplate: [{\n                type: Input,\n                args: ['nfFallback']\n            }], loadingTemplate: [{\n                type: Input,\n                args: ['nfLoadingTemplate']\n            }], errorTemplate: [{\n                type: Input,\n                args: ['nfErrorTemplate']\n            }], inputs: [{\n                type: Input,\n                args: ['nfInputs']\n            }] } });","originalLength":22919,"removedExports":[],"renderedExports":["LoadFederatedComponentDirective"],"renderedLength":7415},"/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/angular/native-federation.module.mjs":{"code":"class NativeFederationModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationModule, declarations: [LoadFederatedComponentDirective$1], imports: [CommonModule], exports: [LoadFederatedComponentDirective$1] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationModule, providers: [\n            NativeFederationService\n        ], imports: [CommonModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [\n                        LoadFederatedComponentDirective$1\n                    ],\n                    imports: [\n                        CommonModule\n                    ],\n                    providers: [\n                        NativeFederationService\n                    ],\n                    exports: [\n                        LoadFederatedComponentDirective$1\n                    ]\n                }]\n        }] });","originalLength":3309,"removedExports":[],"renderedExports":["NativeFederationModule"],"renderedLength":1318},"/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/angular/ssr-integration.mjs":{"code":"/**\n * Angular service for Native Federation SSR support\n */\nclass SSRFederationService {\n    platformId = inject(PLATFORM_ID);\n    transferState = inject(TransferState);\n    ssrLoader = inject(SSRModuleLoader);\n    hydrationClient = inject(HydrationClient);\n    clientLoader;\n    FEDERATION_STATE_KEY = makeStateKey('NF_SSR_STATE');\n    constructor() {\n        if (isPlatformServer(this.platformId)) {\n            this.initializeSSR();\n        }\n        else {\n            this.initializeClient();\n        }\n    }\n    /**\n     * Load remote module with SSR/hydration support\n     */\n    async loadRemoteModule(remoteName, modulePath) {\n        if (isPlatformServer(this.platformId)) {\n            return this.loadRemoteModuleSSR(remoteName, modulePath);\n        }\n        else {\n            return this.loadRemoteModuleClient(remoteName, modulePath);\n        }\n    }\n    /**\n     * Load shared module with SSR/hydration support\n     */\n    async loadSharedModule(packageName) {\n        if (isPlatformServer(this.platformId)) {\n            return this.ssrLoader.loadSharedModule(packageName);\n        }\n        else {\n            return this.clientLoader.loadSharedModule(packageName);\n        }\n    }\n    /**\n     * Check if module was server-rendered\n     */\n    wasServerRendered(remoteName, modulePath) {\n        if (isPlatformBrowser(this.platformId)) {\n            return this.clientLoader?.wasServerRendered(remoteName, modulePath) || false;\n        }\n        return false;\n    }\n    /**\n     * Get SSR content for a remote module (server-side only)\n     */\n    async getSSRContent(remoteName, modulePath) {\n        if (isPlatformServer(this.platformId)) {\n            try {\n                const result = await this.ssrLoader.loadRemoteModule(remoteName, modulePath);\n                return result.ssrContent || null;\n            }\n            catch (error) {\n                console.warn(`[SSR] Failed to get SSR content for ${remoteName}${modulePath}:`, error);\n                return null;\n            }\n        }\n        return null;\n    }\n    async initializeSSR() {\n        // SSRModuleLoader is injected via DI\n        await this.ssrLoader.initialize();\n    }\n    async initializeClient() {\n        // HydrationClient is injected via DI\n        this.clientLoader = await AngularHydrationUtils.initializeForAngularSSR(this.hydrationClient, './federation.manifest.json');\n        // Restore SSR state from TransferState\n        const ssrState = this.transferState.get(this.FEDERATION_STATE_KEY, null);\n        if (ssrState) {\n            // Process any SSR state if needed\n            console.log('[NF] Restored SSR state:', ssrState);\n        }\n    }\n    async loadRemoteModuleSSR(remoteName, modulePath) {\n        const result = await this.ssrLoader.loadRemoteModule(remoteName, modulePath);\n        // Store hydration data in TransferState for client\n        if (result.hydrationData) {\n            const currentState = this.transferState.get(this.FEDERATION_STATE_KEY, {});\n            currentState[`${remoteName}${modulePath}`] = result.hydrationData;\n            this.transferState.set(this.FEDERATION_STATE_KEY, currentState);\n        }\n        return result.module;\n    }\n    async loadRemoteModuleClient(remoteName, modulePath) {\n        return this.clientLoader.loadRemoteModule(remoteName, modulePath);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: SSRFederationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: SSRFederationService, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: SSRFederationService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [] });\nclass LoadFederatedComponentDirective {\n    nfLoadComponent; // Format: \"remoteName/modulePath\"\n    nfFallback;\n    federationService = inject(SSRFederationService);\n    viewContainer = inject(ViewContainerRef);\n    async ngOnInit() {\n        if (!this.nfLoadComponent) {\n            return;\n        }\n        const [remoteName, ...modulePathParts] = this.nfLoadComponent.split('/');\n        const modulePath = './' + modulePathParts.join('/');\n        try {\n            // Check if component was server-rendered\n            if (this.federationService.wasServerRendered?.(remoteName, modulePath)) {\n                console.log(`[NF] Component ${this.nfLoadComponent} was server-rendered, hydrating...`);\n            }\n            const module = await this.federationService.loadRemoteModule(remoteName, modulePath);\n            // Assume the module exports a component as default\n            const component = module.default || module;\n            if (component) {\n                this.viewContainer.createComponent(component);\n            }\n            else {\n                this.renderFallback();\n            }\n        }\n        catch (error) {\n            console.error(`[NF] Failed to load component ${this.nfLoadComponent}:`, error);\n            this.renderFallback();\n        }\n    }\n    ngOnDestroy() {\n        this.viewContainer.clear();\n    }\n    renderFallback() {\n        if (this.nfFallback) {\n            // Render fallback template\n            this.viewContainer.clear();\n            // You would implement fallback rendering logic here\n            console.log(`[NF] Rendering fallback for ${this.nfLoadComponent}: ${this.nfFallback}`);\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: LoadFederatedComponentDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.2.13\", type: LoadFederatedComponentDirective, isStandalone: true, selector: \"[nfLoadComponent]\", inputs: { nfLoadComponent: \"nfLoadComponent\", nfFallback: \"nfFallback\" }, ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: LoadFederatedComponentDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[nfLoadComponent]',\n                    standalone: true\n                }]\n        }], propDecorators: { nfLoadComponent: [{\n                type: Input\n            }], nfFallback: [{\n                type: Input\n            }] } });\n/**\n * Angular helper functions for SSR setup\n */\nclass AngularSSRHelpers {\n    /**\n     * Setup SSR module loader in Angular Universal\n     */\n    static setupSSRLoader(versionManager, manifestPath) {\n        const loader = new SSRModuleLoader(versionManager, {\n            manifestPath\n        });\n        return loader;\n    }\n    /**\n     * Generate hydration script for Angular Universal\n     */\n    static generateHydrationScript(ssrLoader) {\n        const hydrationManifest = ssrLoader.generateHydrationManifest();\n        return SSRFederationUtils.injectHydrationScript('', hydrationManifest);\n    }\n    /**\n     * Create Angular Universal render function with federation support\n     */\n    static createUniversalRenderFunction(originalRenderFn, manifestPath) {\n        return async function renderWithFederation(options) {\n            // Initialize SSR loader\n            // TODO: versionManager should be provided via DI\n            const ssrLoader = AngularSSRHelpers.setupSSRLoader(null, manifestPath);\n            // Add to options so components can access it\n            options.ssrLoader = ssrLoader;\n            // Call original render function\n            const result = await originalRenderFn(options);\n            // Inject hydration script\n            if (typeof result === 'string') {\n                const hydrationScript = AngularSSRHelpers.generateHydrationScript(ssrLoader);\n                return SSRFederationUtils.injectHydrationScript(result, ssrLoader.generateHydrationManifest());\n            }\n            return result;\n        };\n    }\n}\n/**\n * Provider for Angular app configuration\n */\nfunction createSSRFederationProviders(manifestPath) {\n    return [\n        SSRFederationService,\n        {\n            provide: 'NF_MANIFEST_PATH',\n            useValue: manifestPath || './federation.manifest.json'\n        }\n    ];\n}\n/**\n * Angular Universal Federation Provider\n */\nconst AngularUniversalFederationProvider = {\n    provide: SSRFederationService,\n    useClass: SSRFederationService\n};","originalLength":27640,"removedExports":[],"renderedExports":["SSRFederationService","LoadFederatedComponentDirective","AngularSSRHelpers","createSSRFederationProviders","AngularUniversalFederationProvider"],"renderedLength":8547},"/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/lib/types/federation.mjs":{"code":"","originalLength":2841,"removedExports":[],"renderedExports":[],"renderedLength":0},"/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/public-api.mjs":{"code":"/*\n * Public API Surface of @native-federation/core\n */\n// Runtime (Browser-compatible)","originalLength":2439,"removedExports":[],"renderedExports":[],"renderedLength":87},"/Users/sahassakhare/my projects/native federation/dist/native-federation/esm2022/native-federation-core.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":536,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { Injectable, Optional, Directive, Input, NgModule, inject, PLATFORM_ID, TransferState, makeStateKey, ViewContainerRef } from '@angular/core';\nimport * as semver from 'semver';\nimport { CommonModule, isPlatformServer, isPlatformBrowser } from '@angular/common';\n\nclass VersionManager {\n    availableVersions = new Map();\n    installedVersions = new Map();\n    async resolveVersion(packageName, strategy = { type: 'compatible' }) {\n        const installedVersion = this.installedVersions.get(packageName);\n        const availableVersions = this.availableVersions.get(packageName) || [];\n        switch (strategy.type) {\n            case 'exact':\n                if (!installedVersion) {\n                    throw new Error(`Exact version required but ${packageName} not installed`);\n                }\n                return installedVersion;\n            case 'compatible':\n                return this.findCompatibleVersion(packageName, installedVersion, availableVersions);\n            case 'fallback':\n                try {\n                    return this.findCompatibleVersion(packageName, installedVersion, availableVersions);\n                }\n                catch {\n                    if (strategy.fallbackVersion) {\n                        return strategy.fallbackVersion;\n                    }\n                    throw new Error(`No compatible version found for ${packageName} and no fallback provided`);\n                }\n            case 'error':\n                if (!this.isVersionCompatible(installedVersion, availableVersions)) {\n                    throw new Error(`Version conflict for ${packageName}: installed ${installedVersion}, available ${availableVersions.join(', ')}`);\n                }\n                return installedVersion;\n            default:\n                throw new Error(`Unknown version strategy: ${strategy.type}`);\n        }\n    }\n    findCompatibleVersion(packageName, installedVersion, availableVersions = []) {\n        if (!installedVersion) {\n            if (availableVersions.length > 0) {\n                return availableVersions[0];\n            }\n            throw new Error(`No version available for ${packageName}`);\n        }\n        if (availableVersions.length === 0) {\n            return installedVersion;\n        }\n        const compatibleVersions = availableVersions.filter(version => this.areVersionsCompatible(installedVersion, version));\n        if (compatibleVersions.length === 0) {\n            throw new Error(`No compatible version found for ${packageName}. Installed: ${installedVersion}, Available: ${availableVersions.join(', ')}`);\n        }\n        return this.selectBestVersion(compatibleVersions);\n    }\n    areVersionsCompatible(version1, version2) {\n        try {\n            const range1 = semver.major(version1);\n            const range2 = semver.major(version2);\n            return range1 === range2;\n        }\n        catch {\n            return version1 === version2;\n        }\n    }\n    isVersionCompatible(installedVersion, availableVersions = []) {\n        if (!installedVersion || availableVersions.length === 0) {\n            return true;\n        }\n        return availableVersions.some(version => this.areVersionsCompatible(installedVersion, version));\n    }\n    selectBestVersion(versions) {\n        try {\n            return semver.rsort(versions)[0];\n        }\n        catch {\n            return versions[0];\n        }\n    }\n    registerInstalledVersion(packageName, version) {\n        this.installedVersions.set(packageName, version);\n    }\n    registerAvailableVersions(packageName, versions) {\n        this.availableVersions.set(packageName, versions);\n    }\n    getInstalledVersion(packageName) {\n        return this.installedVersions.get(packageName);\n    }\n    getAvailableVersions(packageName) {\n        return this.availableVersions.get(packageName) || [];\n    }\n    validateVersionConstraint(packageName, constraint) {\n        const installedVersion = this.installedVersions.get(packageName);\n        if (!installedVersion) {\n            return false;\n        }\n        try {\n            return semver.satisfies(installedVersion, constraint);\n        }\n        catch {\n            return installedVersion === constraint;\n        }\n    }\n    clear() {\n        this.availableVersions.clear();\n        this.installedVersions.clear();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: VersionManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: VersionManager, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: VersionManager, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });\n\nclass ModuleLoader {\n    versionManager;\n    loadedModules = new Map();\n    manifest = {};\n    importMapElement;\n    constructor(versionManager) {\n        this.versionManager = versionManager;\n    }\n    async initialize(manifestPath) {\n        if (manifestPath) {\n            this.manifest = await this.loadManifest(manifestPath);\n        }\n        await this.setupImportMaps();\n    }\n    async loadRemoteModule(remoteName, modulePath) {\n        const moduleId = `${remoteName}${modulePath}`;\n        if (this.loadedModules.has(moduleId)) {\n            const moduleInfo = this.loadedModules.get(moduleId);\n            if (moduleInfo.loaded) {\n                return import(moduleInfo.url);\n            }\n        }\n        const remoteUrl = await this.resolveRemoteUrl(remoteName);\n        const moduleUrl = await this.resolveModuleUrl(remoteUrl, modulePath);\n        try {\n            const module = await this.loadModule(moduleUrl);\n            this.loadedModules.set(moduleId, {\n                id: moduleId,\n                name: remoteName,\n                version: '1.0.0',\n                url: moduleUrl,\n                deps: [],\n                loaded: true,\n                singleton: false\n            });\n            return module;\n        }\n        catch (error) {\n            throw new Error(`Failed to load remote module ${remoteName}${modulePath}: ${error.message}`);\n        }\n    }\n    async loadSharedModule(packageName, versionStrategy) {\n        const moduleInfo = this.loadedModules.get(packageName);\n        if (moduleInfo?.singleton && moduleInfo.loaded) {\n            return import(moduleInfo.url);\n        }\n        const resolvedVersion = await this.versionManager.resolveVersion(packageName, versionStrategy);\n        const moduleUrl = await this.resolveSharedModuleUrl(packageName, resolvedVersion);\n        try {\n            const module = await this.loadModule(moduleUrl);\n            this.loadedModules.set(packageName, {\n                id: packageName,\n                name: packageName,\n                version: resolvedVersion,\n                url: moduleUrl,\n                deps: [],\n                loaded: true,\n                singleton: true\n            });\n            return module;\n        }\n        catch (error) {\n            if (versionStrategy?.type === 'fallback' && versionStrategy.fallbackVersion) {\n                return this.loadSharedModule(packageName, {\n                    type: 'exact',\n                });\n            }\n            throw new Error(`Failed to load shared module ${packageName}: ${error.message}`);\n        }\n    }\n    async loadManifest(manifestPath) {\n        try {\n            const response = await fetch(manifestPath);\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            return await response.json();\n        }\n        catch (error) {\n            console.warn(`[Native Federation] Failed to load manifest from ${manifestPath}:`, error.message);\n            return {};\n        }\n    }\n    async setupImportMaps() {\n        try {\n            const importMapResponse = await fetch('./importmap.json');\n            if (importMapResponse.ok) {\n                const importMap = await importMapResponse.json();\n                this.injectImportMap(importMap);\n            }\n        }\n        catch (error) {\n            console.warn('[Native Federation] Failed to load import map:', error.message);\n        }\n    }\n    injectImportMap(importMap) {\n        if (this.importMapElement) {\n            this.importMapElement.remove();\n        }\n        this.importMapElement = document.createElement('script');\n        this.importMapElement.type = 'importmap';\n        this.importMapElement.textContent = JSON.stringify(importMap);\n        document.head.appendChild(this.importMapElement);\n    }\n    async resolveRemoteUrl(remoteName) {\n        if (this.manifest[remoteName]) {\n            return this.manifest[remoteName];\n        }\n        throw new Error(`Remote ${remoteName} not found in manifest`);\n    }\n    async resolveModuleUrl(remoteUrl, modulePath) {\n        try {\n            const response = await fetch(remoteUrl);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch remote entry: HTTP ${response.status}`);\n            }\n            const remoteEntry = await response.json();\n            if (!remoteEntry.metadata?.exposes?.[modulePath]) {\n                throw new Error(`Module ${modulePath} not exposed by remote`);\n            }\n            const baseUrl = new URL(remoteUrl).origin;\n            const exposedPath = remoteEntry.metadata.exposes[modulePath];\n            return new URL(exposedPath, baseUrl).href;\n        }\n        catch (error) {\n            throw new Error(`Failed to resolve module URL: ${error.message}`);\n        }\n    }\n    async resolveSharedModuleUrl(packageName, version) {\n        const baseUrl = window.location.origin;\n        return `${baseUrl}/node_modules/.cache/native-federation/esm-packages/${packageName}/index.mjs`;\n    }\n    async loadModule(url) {\n        try {\n            return await import(url);\n        }\n        catch (error) {\n            throw new Error(`Module import failed: ${error.message}`);\n        }\n    }\n    getLoadedModules() {\n        return new Map(this.loadedModules);\n    }\n    async preloadModule(remoteName, modulePath) {\n        const link = document.createElement('link');\n        link.rel = 'modulepreload';\n        link.href = await this.resolveModuleUrl(await this.resolveRemoteUrl(remoteName), modulePath);\n        document.head.appendChild(link);\n    }\n    clearCache() {\n        this.loadedModules.clear();\n        if (this.importMapElement) {\n            this.importMapElement.remove();\n            this.importMapElement = undefined;\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: ModuleLoader, deps: [{ token: VersionManager }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: ModuleLoader, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: ModuleLoader, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: VersionManager }] });\n\nclass FederationRuntime {\n    moduleLoader;\n    initialized = false;\n    manifest = null;\n    constructor(moduleLoader) {\n        this.moduleLoader = moduleLoader;\n    }\n    async initialize(manifestPath) {\n        if (this.initialized) {\n            console.warn('[Native Federation] Federation already initialized');\n            return;\n        }\n        try {\n            await this.moduleLoader.initialize(manifestPath);\n            this.initialized = true;\n            if (typeof window !== 'undefined') {\n                window.__nativeFederation = {\n                    loadRemoteModule: this.loadRemoteModule.bind(this),\n                    loadSharedModule: this.loadSharedModule.bind(this),\n                    preloadModule: this.preloadModule.bind(this),\n                    getLoadedModules: this.getLoadedModules.bind(this),\n                    clearCache: this.clearCache.bind(this)\n                };\n            }\n            console.log('[Native Federation] Federation initialized successfully');\n        }\n        catch (error) {\n            console.error('[Native Federation] Failed to initialize federation:', error);\n            throw error;\n        }\n    }\n    async loadRemoteModule(remoteName, modulePath) {\n        if (!this.initialized) {\n            throw new Error('[Native Federation] Federation not initialized. Call initialize() first.');\n        }\n        return this.moduleLoader.loadRemoteModule(remoteName, modulePath);\n    }\n    async loadSharedModule(packageName) {\n        if (!this.initialized) {\n            throw new Error('[Native Federation] Federation not initialized. Call initialize() first.');\n        }\n        return this.moduleLoader.loadSharedModule(packageName);\n    }\n    async preloadModule(remoteName, modulePath) {\n        if (!this.initialized) {\n            throw new Error('[Native Federation] Federation not initialized. Call initialize() first.');\n        }\n        return this.moduleLoader.preloadModule(remoteName, modulePath);\n    }\n    getLoadedModules() {\n        if (!this.initialized) {\n            return new Map();\n        }\n        return this.moduleLoader.getLoadedModules();\n    }\n    clearCache() {\n        this.moduleLoader.clearCache();\n    }\n    isInitialized() {\n        return this.initialized;\n    }\n    async reinitialize(manifestPath) {\n        this.moduleLoader.clearCache();\n        this.initialized = false;\n        await this.initialize(manifestPath);\n    }\n    getFederationStatus() {\n        return {\n            initialized: this.initialized,\n            loadedModulesCount: this.moduleLoader.getLoadedModules().size,\n            hasModuleLoader: true\n        };\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: FederationRuntime, deps: [{ token: ModuleLoader }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: FederationRuntime, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: FederationRuntime, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: ModuleLoader }] });\n// Export functions for backward compatibility\nasync function initFederation(manifestPath) {\n    // Deprecated - use FederationRuntime class instead\n    console.warn('[Native Federation] initFederation() is deprecated. Use FederationRuntime class instead.');\n}\nasync function loadRemoteModule(remoteName, modulePath) {\n    // Deprecated - use FederationRuntime class instead\n    throw new Error('[Native Federation] loadRemoteModule() is deprecated. Use FederationRuntime class instead.');\n}\n\n/**\n * Server-side module loader for SSR environments\n * Handles module federation during server-side rendering\n */\nclass SSRModuleLoader {\n    versionManager;\n    loadedModules = new Map();\n    manifest = {};\n    moduleCache = new Map();\n    manifestPath;\n    ssrContext;\n    constructor(versionManager, ssrContext) {\n        this.versionManager = versionManager;\n        this.manifestPath = ssrContext?.manifestPath;\n        this.ssrContext = ssrContext;\n    }\n    async initialize() {\n        if (this.manifestPath) {\n            this.manifest = await this.loadManifest(this.manifestPath);\n        }\n    }\n    /**\n     * Load remote module during SSR\n     * Returns pre-rendered content and hydration instructions\n     */\n    async loadRemoteModule(remoteName, modulePath) {\n        const moduleId = `${remoteName}${modulePath}`;\n        // Check cache first\n        if (this.moduleCache.has(moduleId)) {\n            return { module: this.moduleCache.get(moduleId) };\n        }\n        try {\n            // In SSR, we need to resolve module path differently\n            const moduleUrl = await this.resolveSSRModuleUrl(remoteName, modulePath);\n            const module = await this.loadSSRModule(moduleUrl);\n            // Cache the module\n            this.moduleCache.set(moduleId, module);\n            this.loadedModules.set(moduleId, {\n                id: moduleId,\n                name: remoteName,\n                version: '1.0.0',\n                url: moduleUrl,\n                deps: [],\n                loaded: true,\n                singleton: false\n            });\n            // Extract SSR content if available\n            let ssrContent;\n            let hydrationData;\n            if (module.renderToString && typeof module.renderToString === 'function') {\n                ssrContent = await module.renderToString();\n            }\n            if (module.getHydrationData && typeof module.getHydrationData === 'function') {\n                hydrationData = await module.getHydrationData();\n            }\n            return { module, ssrContent, hydrationData };\n        }\n        catch (error) {\n            // In SSR, we might want to return fallback content instead of throwing\n            console.warn(`[SSR] Failed to load remote module ${remoteName}${modulePath}:`, error.message);\n            return {\n                module: this.createFallbackModule(remoteName, modulePath),\n                ssrContent: `<!-- SSR: Failed to load ${remoteName}${modulePath} -->`,\n                hydrationData: { fallback: true, remoteName, modulePath }\n            };\n        }\n    }\n    /**\n     * Load shared module during SSR\n     */\n    async loadSharedModule(packageName, versionStrategy) {\n        const moduleInfo = this.loadedModules.get(packageName);\n        if (moduleInfo?.singleton && moduleInfo.loaded && this.moduleCache.has(packageName)) {\n            return this.moduleCache.get(packageName);\n        }\n        try {\n            // In Node.js environment, we can use require\n            const module = this.ssrContext?.require\n                ? this.ssrContext.require(packageName)\n                : await import(packageName);\n            this.moduleCache.set(packageName, module);\n            this.loadedModules.set(packageName, {\n                id: packageName,\n                name: packageName,\n                version: '1.0.0', // We'd need to resolve this properly\n                url: packageName,\n                deps: [],\n                loaded: true,\n                singleton: true\n            });\n            return module;\n        }\n        catch (error) {\n            throw new Error(`Failed to load shared module ${packageName} in SSR: ${error.message}`);\n        }\n    }\n    /**\n     * Generate hydration manifest for client-side\n     */\n    generateHydrationManifest() {\n        const loadedModules = [];\n        this.loadedModules.forEach((moduleInfo) => {\n            loadedModules.push({\n                id: moduleInfo.id,\n                name: moduleInfo.name,\n                url: moduleInfo.url,\n                hydrationData: moduleInfo.hydrationData\n            });\n        });\n        return {\n            loadedModules,\n            importMap: this.generateImportMap()\n        };\n    }\n    async loadManifest(manifestPath) {\n        try {\n            const fetchFn = this.ssrContext?.fetch || fetch;\n            const response = await fetchFn(manifestPath);\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            return await response.json();\n        }\n        catch (error) {\n            console.warn(`[SSR] Failed to load manifest from ${manifestPath}:`, error.message);\n            return {};\n        }\n    }\n    async resolveSSRModuleUrl(remoteName, modulePath) {\n        // In SSR, we might need to resolve to local file paths or URLs\n        if (this.manifest[remoteName]) {\n            const remoteUrl = this.manifest[remoteName];\n            // Handle local file paths for SSR\n            if (remoteUrl.startsWith('/') || remoteUrl.startsWith('./')) {\n                return `${remoteUrl}${modulePath}`;\n            }\n            // Handle remote URLs\n            return `${remoteUrl}${modulePath}`;\n        }\n        throw new Error(`Remote ${remoteName} not found in SSR manifest`);\n    }\n    async loadSSRModule(url) {\n        try {\n            // In Node.js environment, handle different module loading strategies\n            if (url.startsWith('http')) {\n                // Remote module - might need special handling\n                const fetchFn = this.ssrContext?.fetch || fetch;\n                const response = await fetchFn(url);\n                const moduleCode = await response.text();\n                // In production SSR, you'd want to evaluate this safely\n                // For now, we'll simulate a module structure\n                return { default: null, __ssrModule: true };\n            }\n            else {\n                // Local module\n                return this.ssrContext?.require\n                    ? this.ssrContext.require(url)\n                    : await import(url);\n            }\n        }\n        catch (error) {\n            throw new Error(`SSR module import failed: ${error.message}`);\n        }\n    }\n    createFallbackModule(remoteName, modulePath) {\n        return {\n            default: null,\n            __fallback: true,\n            __remoteName: remoteName,\n            __modulePath: modulePath,\n            renderToString: () => `<!-- Fallback for ${remoteName}${modulePath} -->`,\n            getHydrationData: () => ({ fallback: true })\n        };\n    }\n    generateImportMap() {\n        const importMap = {};\n        this.loadedModules.forEach((moduleInfo) => {\n            if (moduleInfo.name.startsWith('@') || !moduleInfo.name.includes('/')) {\n                // Shared dependency\n                importMap[moduleInfo.name] = moduleInfo.url;\n            }\n        });\n        return importMap;\n    }\n    getLoadedModules() {\n        return new Map(this.loadedModules);\n    }\n    clearCache() {\n        this.loadedModules.clear();\n        this.moduleCache.clear();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: SSRModuleLoader, deps: \"invalid\", target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: SSRModuleLoader, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: SSRModuleLoader, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: VersionManager }, { type: undefined, decorators: [{\n                    type: Optional\n                }] }] });\n/**\n * SSR utilities for framework integration\n */\nclass SSRFederationUtils {\n    static injectHydrationScript(html, hydrationManifest) {\n        const script = `\n      <script type=\"module\">\n        // Hydration data for Native Federation\n        window.__NF_HYDRATION__ = ${JSON.stringify(hydrationManifest)};\n        \n        // Pre-populate module cache\n        if (window.__NF_HYDRATION__.loadedModules) {\n          window.__NF_LOADED_MODULES__ = new Map();\n          window.__NF_HYDRATION__.loadedModules.forEach(mod => {\n            window.__NF_LOADED_MODULES__.set(mod.id, mod);\n          });\n        }\n      </script>\n    `;\n        // Inject before closing head tag\n        return html.replace('</head>', `${script}</head>`);\n    }\n    static generatePreloadLinks(loadedModules) {\n        return loadedModules\n            .map(mod => `<link rel=\"modulepreload\" href=\"${mod.url}\">`)\n            .join('\\n');\n    }\n}\n\n/**\n * Client-side hydration support for SSR\n * Resumes federation state from server-rendered content\n */\nclass HydrationClient extends ModuleLoader {\n    hydrationData;\n    ssrModuleCache = new Map();\n    constructor(versionManager) {\n        super(versionManager);\n    }\n    async initializeWithHydration(manifestPath) {\n        // Extract hydration data from SSR\n        this.extractHydrationData();\n        // Initialize base module loader\n        await this.initialize(manifestPath);\n        // Restore SSR module cache\n        await this.restoreSSRModules();\n    }\n    /**\n     * Load remote module with hydration support\n     * Checks SSR cache first, then falls back to normal loading\n     */\n    async loadRemoteModule(remoteName, modulePath) {\n        const moduleId = `${remoteName}${modulePath}`;\n        // Check if module was loaded during SSR\n        if (this.ssrModuleCache.has(moduleId)) {\n            const cached = this.ssrModuleCache.get(moduleId);\n            // If it's a fallback, try to load the real module\n            if (cached.__fallback) {\n                try {\n                    return await super.loadRemoteModule(remoteName, modulePath);\n                }\n                catch (error) {\n                    console.warn(`[Hydration] Failed to load real module, using fallback:`, error);\n                    return cached;\n                }\n            }\n            return cached;\n        }\n        // Fall back to normal loading\n        return super.loadRemoteModule(remoteName, modulePath);\n    }\n    /**\n     * Check if module was server-rendered\n     */\n    wasServerRendered(remoteName, modulePath) {\n        const moduleId = `${remoteName}${modulePath}`;\n        return this.ssrModuleCache.has(moduleId);\n    }\n    /**\n     * Get hydration data for a specific module\n     */\n    getModuleHydrationData(remoteName, modulePath) {\n        const moduleId = `${remoteName}${modulePath}`;\n        const cached = this.ssrModuleCache.get(moduleId);\n        return cached?.hydrationData;\n    }\n    extractHydrationData() {\n        // Extract hydration data injected by SSR\n        const hydrationData = window.__NF_HYDRATION__;\n        const loadedModules = window.__NF_LOADED_MODULES__;\n        if (hydrationData) {\n            this.hydrationData = hydrationData;\n            // Restore import map if available\n            if (hydrationData.importMap) {\n                this.injectHydrationImportMap({ imports: hydrationData.importMap });\n            }\n        }\n        if (loadedModules) {\n            loadedModules.forEach((moduleInfo, moduleId) => {\n                this.ssrModuleCache.set(moduleId, {\n                    ...moduleInfo,\n                    __fromSSR: true\n                });\n            });\n        }\n    }\n    async restoreSSRModules() {\n        if (!this.hydrationData?.loadedModules) {\n            return;\n        }\n        // Process each module that was loaded during SSR\n        for (const moduleInfo of this.hydrationData.loadedModules) {\n            try {\n                // For non-fallback modules, try to establish client-side reference\n                if (!moduleInfo.hydrationData?.fallback) {\n                    const module = await import(moduleInfo.url);\n                    this.ssrModuleCache.set(moduleInfo.id, module);\n                }\n            }\n            catch (error) {\n                console.warn(`[Hydration] Could not restore module ${moduleInfo.id}:`, error);\n            }\n        }\n    }\n    injectHydrationImportMap(importMap) {\n        const existingScript = document.querySelector('script[type=\"importmap\"]');\n        if (existingScript) {\n            // Merge with existing import map\n            const existing = JSON.parse(existingScript.textContent || '{}');\n            const merged = {\n                imports: {\n                    ...existing.imports,\n                    ...importMap.imports\n                }\n            };\n            existingScript.textContent = JSON.stringify(merged);\n        }\n        else {\n            // Create new import map\n            const script = document.createElement('script');\n            script.type = 'importmap';\n            script.textContent = JSON.stringify(importMap);\n            document.head.appendChild(script);\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: HydrationClient, deps: [{ token: VersionManager }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: HydrationClient, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: HydrationClient, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: VersionManager }] });\n/**\n * Angular-specific hydration utilities\n */\nclass AngularHydrationUtils {\n    /**\n     * Initialize Native Federation with Angular Universal hydration\n     */\n    static async initializeForAngularSSR(client, manifestPath) {\n        await client.initializeWithHydration(manifestPath);\n        // Wait for Angular hydration to complete before loading remote modules\n        if (window.ng && window.ng.getInjector) {\n            await this.waitForAngularHydration();\n        }\n        return client;\n    }\n    /**\n     * Wait for Angular hydration to complete\n     */\n    static async waitForAngularHydration() {\n        return new Promise((resolve) => {\n            const checkHydration = () => {\n                const appRef = window.ng?.getInjector?.()?.get?.('ApplicationRef');\n                if (appRef && appRef.isStable) {\n                    appRef.isStable.subscribe((stable) => {\n                        if (stable) {\n                            resolve();\n                        }\n                    });\n                }\n                else {\n                    // Fallback: wait a bit and try again\n                    setTimeout(checkHydration, 100);\n                }\n            };\n            checkHydration();\n        });\n    }\n    /**\n     * Create Angular component wrapper that handles SSR/hydration\n     */\n    static createSSRComponent(loader, fallbackTemplate = '<div>Loading...</div>') {\n        return {\n            template: fallbackTemplate,\n            async ngOnInit() {\n                try {\n                    const { default: Component } = await loader();\n                    // Dynamic component loading logic would go here\n                    // This would integrate with Angular's ViewContainerRef\n                }\n                catch (error) {\n                    console.error('Failed to load federated component:', error);\n                }\n            }\n        };\n    }\n}\n/**\n * Universal federation runtime that works in both SSR and client\n */\nclass UniversalFederationRuntime {\n    hydrationClient;\n    isSSR;\n    constructor(hydrationClient) {\n        this.hydrationClient = hydrationClient;\n        this.isSSR = typeof window === 'undefined';\n    }\n    async initialize(manifestPath) {\n        if (this.isSSR) {\n            // SSR initialization will be handled separately\n            return;\n        }\n        await this.hydrationClient.initializeWithHydration(manifestPath);\n    }\n    async loadRemoteModule(remoteName, modulePath) {\n        if (this.isSSR) {\n            throw new Error('SSR module loading should use SSRModuleLoader directly');\n        }\n        return this.hydrationClient.loadRemoteModule(remoteName, modulePath);\n    }\n    async loadSharedModule(packageName) {\n        return this.hydrationClient.loadSharedModule(packageName);\n    }\n    wasServerRendered(remoteName, modulePath) {\n        if (this.isSSR) {\n            return false;\n        }\n        return this.hydrationClient.wasServerRendered(remoteName, modulePath);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: UniversalFederationRuntime, deps: [{ token: HydrationClient }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: UniversalFederationRuntime, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: UniversalFederationRuntime, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: HydrationClient }] });\n\nclass NativeFederationService {\n    runtime;\n    moduleLoader;\n    constructor(runtime, moduleLoader) {\n        this.runtime = runtime;\n        this.moduleLoader = moduleLoader;\n    }\n    /**\n     * Initialize the federation runtime with a manifest\n     */\n    async initialize(manifestUrl) {\n        await this.runtime.initialize(manifestUrl);\n    }\n    /**\n     * Load a remote module dynamically\n     */\n    async loadRemoteModule(remoteName, modulePath) {\n        return this.moduleLoader.loadRemoteModule(remoteName, modulePath);\n    }\n    /**\n     * Check if a module is loaded\n     */\n    isModuleLoaded(remoteName, modulePath) {\n        const moduleId = `${remoteName}${modulePath}`;\n        return this.moduleLoader.getLoadedModules().has(moduleId);\n    }\n    /**\n     * Preload a remote module\n     */\n    async preloadModule(remoteName, modulePath) {\n        await this.moduleLoader.preloadModule(remoteName, modulePath);\n    }\n    /**\n     * Get the runtime instance for advanced usage\n     */\n    getRuntime() {\n        return this.runtime;\n    }\n    /**\n     * Get the module loader instance for advanced usage\n     */\n    getModuleLoader() {\n        return this.moduleLoader;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationService, deps: [{ token: FederationRuntime }, { token: ModuleLoader }], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationService, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [{ type: FederationRuntime }, { type: ModuleLoader }] });\n\nlet LoadFederatedComponentDirective$1 = class LoadFederatedComponentDirective {\n    viewContainer;\n    federationService;\n    cdr;\n    injector;\n    componentInfo;\n    fallbackTemplate;\n    loadingTemplate;\n    errorTemplate;\n    inputs;\n    componentRef;\n    currentView;\n    isLoading = false;\n    constructor(viewContainer, federationService, cdr, injector) {\n        this.viewContainer = viewContainer;\n        this.federationService = federationService;\n        this.cdr = cdr;\n        this.injector = injector;\n    }\n    async ngOnInit() {\n        await this.loadComponent();\n    }\n    ngOnDestroy() {\n        this.cleanup();\n    }\n    async loadComponent() {\n        if (!this.componentInfo) {\n            console.warn('[LoadFederatedComponentDirective] No component info provided');\n            return;\n        }\n        // Parse component info (format: \"remoteName/modulePath\")\n        const [remoteName, modulePath] = this.componentInfo.split('/');\n        if (!remoteName || !modulePath) {\n            console.error('[LoadFederatedComponentDirective] Invalid component info format. Use \"remoteName/modulePath\"');\n            this.showErrorView('Invalid component format');\n            return;\n        }\n        try {\n            this.isLoading = true;\n            this.showLoadingView();\n            // Load the remote module\n            const module = await this.federationService.loadRemoteModule(remoteName, `./${modulePath}`);\n            // Get the component from the module\n            const ComponentClass = this.getComponentFromModule(module);\n            if (!ComponentClass) {\n                throw new Error(`Component not found in module ${remoteName}/${modulePath}`);\n            }\n            // Create and insert the component\n            await this.createComponent(ComponentClass);\n        }\n        catch (error) {\n            console.error('[LoadFederatedComponentDirective] Failed to load component:', error);\n            this.showErrorView(error instanceof Error ? error.message : 'Unknown error');\n        }\n        finally {\n            this.isLoading = false;\n        }\n    }\n    getComponentFromModule(module) {\n        // Try different common export patterns\n        if (module.default && typeof module.default === 'function') {\n            return module.default;\n        }\n        if (module.Component && typeof module.Component === 'function') {\n            return module.Component;\n        }\n        // Look for the first function export (likely a component)\n        for (const key of Object.keys(module)) {\n            if (typeof module[key] === 'function' && key !== 'default') {\n                return module[key];\n            }\n        }\n        return null;\n    }\n    async createComponent(ComponentClass) {\n        this.cleanup();\n        try {\n            // Create the component\n            this.componentRef = this.viewContainer.createComponent(ComponentClass, {\n                injector: this.injector\n            });\n            // Set inputs if provided\n            if (this.inputs) {\n                Object.keys(this.inputs).forEach(key => {\n                    if (this.componentRef?.instance[key] !== undefined) {\n                        this.componentRef.instance[key] = this.inputs[key];\n                    }\n                });\n            }\n            // Trigger change detection\n            this.componentRef.changeDetectorRef.detectChanges();\n            this.cdr.detectChanges();\n        }\n        catch (error) {\n            console.error('[LoadFederatedComponentDirective] Failed to create component:', error);\n            throw error;\n        }\n    }\n    showLoadingView() {\n        this.cleanup();\n        if (this.loadingTemplate) {\n            this.currentView = this.viewContainer.createEmbeddedView(this.loadingTemplate);\n        }\n        else {\n            // Create default loading view\n            this.createDefaultLoadingView();\n        }\n    }\n    showErrorView(error) {\n        this.cleanup();\n        if (this.errorTemplate) {\n            this.currentView = this.viewContainer.createEmbeddedView(this.errorTemplate, { error });\n        }\n        else if (this.fallbackTemplate) {\n            this.currentView = this.viewContainer.createEmbeddedView(this.fallbackTemplate);\n        }\n        else {\n            // Create default error view\n            this.createDefaultErrorView(error);\n        }\n    }\n    createDefaultLoadingView() {\n        const div = document.createElement('div');\n        div.style.padding = '20px';\n        div.style.textAlign = 'center';\n        div.style.color = '#666';\n        div.innerHTML = '⏳ Loading federated component...';\n        const elementRef = { nativeElement: div };\n        this.currentView = this.viewContainer.createEmbeddedView({ createEmbeddedView: () => ({ rootNodes: [div] }) });\n    }\n    createDefaultErrorView(error) {\n        const div = document.createElement('div');\n        div.style.padding = '20px';\n        div.style.border = '1px solid #f5c6cb';\n        div.style.backgroundColor = '#f8d7da';\n        div.style.color = '#721c24';\n        div.style.borderRadius = '4px';\n        div.innerHTML = `\n      <strong>❌ Failed to load federated component</strong><br>\n      <small>${this.componentInfo}</small><br>\n      <em>${error}</em>\n    `;\n        this.currentView = this.viewContainer.createEmbeddedView({ createEmbeddedView: () => ({ rootNodes: [div] }) });\n    }\n    cleanup() {\n        if (this.componentRef) {\n            this.componentRef.destroy();\n            this.componentRef = undefined;\n        }\n        if (this.currentView) {\n            this.currentView.destroy();\n            this.currentView = undefined;\n        }\n        this.viewContainer.clear();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: LoadFederatedComponentDirective, deps: [{ token: i0.ViewContainerRef }, { token: NativeFederationService }, { token: i0.ChangeDetectorRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.2.13\", type: LoadFederatedComponentDirective, selector: \"[nfLoadComponent]\", inputs: { componentInfo: [\"nfLoadComponent\", \"componentInfo\"], fallbackTemplate: [\"nfFallback\", \"fallbackTemplate\"], loadingTemplate: [\"nfLoadingTemplate\", \"loadingTemplate\"], errorTemplate: [\"nfErrorTemplate\", \"errorTemplate\"], inputs: [\"nfInputs\", \"inputs\"] }, ngImport: i0 });\n};\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: LoadFederatedComponentDirective$1, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[nfLoadComponent]'\n                }]\n        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: NativeFederationService }, { type: i0.ChangeDetectorRef }, { type: i0.Injector }], propDecorators: { componentInfo: [{\n                type: Input,\n                args: ['nfLoadComponent']\n            }], fallbackTemplate: [{\n                type: Input,\n                args: ['nfFallback']\n            }], loadingTemplate: [{\n                type: Input,\n                args: ['nfLoadingTemplate']\n            }], errorTemplate: [{\n                type: Input,\n                args: ['nfErrorTemplate']\n            }], inputs: [{\n                type: Input,\n                args: ['nfInputs']\n            }] } });\n\nclass NativeFederationModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationModule, declarations: [LoadFederatedComponentDirective$1], imports: [CommonModule], exports: [LoadFederatedComponentDirective$1] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationModule, providers: [\n            NativeFederationService\n        ], imports: [CommonModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: NativeFederationModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [\n                        LoadFederatedComponentDirective$1\n                    ],\n                    imports: [\n                        CommonModule\n                    ],\n                    providers: [\n                        NativeFederationService\n                    ],\n                    exports: [\n                        LoadFederatedComponentDirective$1\n                    ]\n                }]\n        }] });\n\n/**\n * Angular service for Native Federation SSR support\n */\nclass SSRFederationService {\n    platformId = inject(PLATFORM_ID);\n    transferState = inject(TransferState);\n    ssrLoader = inject(SSRModuleLoader);\n    hydrationClient = inject(HydrationClient);\n    clientLoader;\n    FEDERATION_STATE_KEY = makeStateKey('NF_SSR_STATE');\n    constructor() {\n        if (isPlatformServer(this.platformId)) {\n            this.initializeSSR();\n        }\n        else {\n            this.initializeClient();\n        }\n    }\n    /**\n     * Load remote module with SSR/hydration support\n     */\n    async loadRemoteModule(remoteName, modulePath) {\n        if (isPlatformServer(this.platformId)) {\n            return this.loadRemoteModuleSSR(remoteName, modulePath);\n        }\n        else {\n            return this.loadRemoteModuleClient(remoteName, modulePath);\n        }\n    }\n    /**\n     * Load shared module with SSR/hydration support\n     */\n    async loadSharedModule(packageName) {\n        if (isPlatformServer(this.platformId)) {\n            return this.ssrLoader.loadSharedModule(packageName);\n        }\n        else {\n            return this.clientLoader.loadSharedModule(packageName);\n        }\n    }\n    /**\n     * Check if module was server-rendered\n     */\n    wasServerRendered(remoteName, modulePath) {\n        if (isPlatformBrowser(this.platformId)) {\n            return this.clientLoader?.wasServerRendered(remoteName, modulePath) || false;\n        }\n        return false;\n    }\n    /**\n     * Get SSR content for a remote module (server-side only)\n     */\n    async getSSRContent(remoteName, modulePath) {\n        if (isPlatformServer(this.platformId)) {\n            try {\n                const result = await this.ssrLoader.loadRemoteModule(remoteName, modulePath);\n                return result.ssrContent || null;\n            }\n            catch (error) {\n                console.warn(`[SSR] Failed to get SSR content for ${remoteName}${modulePath}:`, error);\n                return null;\n            }\n        }\n        return null;\n    }\n    async initializeSSR() {\n        // SSRModuleLoader is injected via DI\n        await this.ssrLoader.initialize();\n    }\n    async initializeClient() {\n        // HydrationClient is injected via DI\n        this.clientLoader = await AngularHydrationUtils.initializeForAngularSSR(this.hydrationClient, './federation.manifest.json');\n        // Restore SSR state from TransferState\n        const ssrState = this.transferState.get(this.FEDERATION_STATE_KEY, null);\n        if (ssrState) {\n            // Process any SSR state if needed\n            console.log('[NF] Restored SSR state:', ssrState);\n        }\n    }\n    async loadRemoteModuleSSR(remoteName, modulePath) {\n        const result = await this.ssrLoader.loadRemoteModule(remoteName, modulePath);\n        // Store hydration data in TransferState for client\n        if (result.hydrationData) {\n            const currentState = this.transferState.get(this.FEDERATION_STATE_KEY, {});\n            currentState[`${remoteName}${modulePath}`] = result.hydrationData;\n            this.transferState.set(this.FEDERATION_STATE_KEY, currentState);\n        }\n        return result.module;\n    }\n    async loadRemoteModuleClient(remoteName, modulePath) {\n        return this.clientLoader.loadRemoteModule(remoteName, modulePath);\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: SSRFederationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: SSRFederationService, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: SSRFederationService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: () => [] });\nclass LoadFederatedComponentDirective {\n    nfLoadComponent; // Format: \"remoteName/modulePath\"\n    nfFallback;\n    federationService = inject(SSRFederationService);\n    viewContainer = inject(ViewContainerRef);\n    async ngOnInit() {\n        if (!this.nfLoadComponent) {\n            return;\n        }\n        const [remoteName, ...modulePathParts] = this.nfLoadComponent.split('/');\n        const modulePath = './' + modulePathParts.join('/');\n        try {\n            // Check if component was server-rendered\n            if (this.federationService.wasServerRendered?.(remoteName, modulePath)) {\n                console.log(`[NF] Component ${this.nfLoadComponent} was server-rendered, hydrating...`);\n            }\n            const module = await this.federationService.loadRemoteModule(remoteName, modulePath);\n            // Assume the module exports a component as default\n            const component = module.default || module;\n            if (component) {\n                this.viewContainer.createComponent(component);\n            }\n            else {\n                this.renderFallback();\n            }\n        }\n        catch (error) {\n            console.error(`[NF] Failed to load component ${this.nfLoadComponent}:`, error);\n            this.renderFallback();\n        }\n    }\n    ngOnDestroy() {\n        this.viewContainer.clear();\n    }\n    renderFallback() {\n        if (this.nfFallback) {\n            // Render fallback template\n            this.viewContainer.clear();\n            // You would implement fallback rendering logic here\n            console.log(`[NF] Rendering fallback for ${this.nfLoadComponent}: ${this.nfFallback}`);\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: LoadFederatedComponentDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.2.13\", type: LoadFederatedComponentDirective, isStandalone: true, selector: \"[nfLoadComponent]\", inputs: { nfLoadComponent: \"nfLoadComponent\", nfFallback: \"nfFallback\" }, ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.13\", ngImport: i0, type: LoadFederatedComponentDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[nfLoadComponent]',\n                    standalone: true\n                }]\n        }], propDecorators: { nfLoadComponent: [{\n                type: Input\n            }], nfFallback: [{\n                type: Input\n            }] } });\n/**\n * Angular helper functions for SSR setup\n */\nclass AngularSSRHelpers {\n    /**\n     * Setup SSR module loader in Angular Universal\n     */\n    static setupSSRLoader(versionManager, manifestPath) {\n        const loader = new SSRModuleLoader(versionManager, {\n            manifestPath\n        });\n        return loader;\n    }\n    /**\n     * Generate hydration script for Angular Universal\n     */\n    static generateHydrationScript(ssrLoader) {\n        const hydrationManifest = ssrLoader.generateHydrationManifest();\n        return SSRFederationUtils.injectHydrationScript('', hydrationManifest);\n    }\n    /**\n     * Create Angular Universal render function with federation support\n     */\n    static createUniversalRenderFunction(originalRenderFn, manifestPath) {\n        return async function renderWithFederation(options) {\n            // Initialize SSR loader\n            // TODO: versionManager should be provided via DI\n            const ssrLoader = AngularSSRHelpers.setupSSRLoader(null, manifestPath);\n            // Add to options so components can access it\n            options.ssrLoader = ssrLoader;\n            // Call original render function\n            const result = await originalRenderFn(options);\n            // Inject hydration script\n            if (typeof result === 'string') {\n                const hydrationScript = AngularSSRHelpers.generateHydrationScript(ssrLoader);\n                return SSRFederationUtils.injectHydrationScript(result, ssrLoader.generateHydrationManifest());\n            }\n            return result;\n        };\n    }\n}\n/**\n * Provider for Angular app configuration\n */\nfunction createSSRFederationProviders(manifestPath) {\n    return [\n        SSRFederationService,\n        {\n            provide: 'NF_MANIFEST_PATH',\n            useValue: manifestPath || './federation.manifest.json'\n        }\n    ];\n}\n/**\n * Angular Universal Federation Provider\n */\nconst AngularUniversalFederationProvider = {\n    provide: SSRFederationService,\n    useClass: SSRFederationService\n};\n\n/*\n * Public API Surface of @native-federation/core\n */\n// Runtime (Browser-compatible)\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularHydrationUtils, AngularUniversalFederationProvider, FederationRuntime, HydrationClient, LoadFederatedComponentDirective$1 as LoadFederatedComponentDirective, ModuleLoader, NativeFederationModule, NativeFederationService, SSRFederationService, SSRFederationUtils, SSRModuleLoader, UniversalFederationRuntime, VersionManager, createSSRFederationProviders, initFederation, loadRemoteModule };\n//# sourceMappingURL=native-federation-core.mjs.map\n","map":null,"preliminaryFileName":"native-federation-core.mjs","sourcemapFileName":"native-federation-core.mjs.map"},{"fileName":"native-federation-core.mjs.map","needsCodeReference":false,"originalFileName":null,"source":"{\"version\":3,\"file\":\"native-federation-core.mjs\",\"sources\":[\"../../../projects/native-federation/src/lib/runtime/version-manager.ts\",\"../../../projects/native-federation/src/lib/runtime/module-loader.ts\",\"../../../projects/native-federation/src/lib/runtime/federation-runtime.ts\",\"../../../projects/native-federation/src/lib/runtime/ssr-module-loader.ts\",\"../../../projects/native-federation/src/lib/runtime/hydration-client.ts\",\"../../../projects/native-federation/src/lib/angular/native-federation.service.ts\",\"../../../projects/native-federation/src/lib/angular/directives/load-federated-component.directive.ts\",\"../../../projects/native-federation/src/lib/angular/native-federation.module.ts\",\"../../../projects/native-federation/src/lib/angular/ssr-integration.ts\",\"../../../projects/native-federation/src/public-api.ts\",\"../../../projects/native-federation/src/native-federation-core.ts\"],\"sourcesContent\":[\"import { Injectable } from '@angular/core';\\nimport { VersionStrategy } from '../types/federation';\\nimport * as semver from 'semver';\\n\\n@Injectable({\\n  providedIn: 'root'\\n})\\nexport class VersionManager {\\n  private availableVersions = new Map<string, string[]>();\\n  private installedVersions = new Map<string, string>();\\n\\n  async resolveVersion(packageName: string, strategy: VersionStrategy = { type: 'compatible' }): Promise<string> {\\n    const installedVersion = this.installedVersions.get(packageName);\\n    const availableVersions = this.availableVersions.get(packageName) || [];\\n\\n    switch (strategy.type) {\\n      case 'exact':\\n        if (!installedVersion) {\\n          throw new Error(`Exact version required but ${packageName} not installed`);\\n        }\\n        return installedVersion;\\n\\n      case 'compatible':\\n        return this.findCompatibleVersion(packageName, installedVersion, availableVersions);\\n\\n      case 'fallback':\\n        try {\\n          return this.findCompatibleVersion(packageName, installedVersion, availableVersions);\\n        } catch {\\n          if (strategy.fallbackVersion) {\\n            return strategy.fallbackVersion;\\n          }\\n          throw new Error(`No compatible version found for ${packageName} and no fallback provided`);\\n        }\\n\\n      case 'error':\\n        if (!this.isVersionCompatible(installedVersion, availableVersions)) {\\n          throw new Error(`Version conflict for ${packageName}: installed ${installedVersion}, available ${availableVersions.join(', ')}`);\\n        }\\n        return installedVersion!;\\n\\n      default:\\n        throw new Error(`Unknown version strategy: ${strategy.type}`);\\n    }\\n  }\\n\\n  private findCompatibleVersion(packageName: string, installedVersion?: string, availableVersions: string[] = []): string {\\n    if (!installedVersion) {\\n      if (availableVersions.length > 0) {\\n        return availableVersions[0];\\n      }\\n      throw new Error(`No version available for ${packageName}`);\\n    }\\n\\n    if (availableVersions.length === 0) {\\n      return installedVersion;\\n    }\\n\\n    const compatibleVersions = availableVersions.filter(version => \\n      this.areVersionsCompatible(installedVersion, version)\\n    );\\n\\n    if (compatibleVersions.length === 0) {\\n      throw new Error(`No compatible version found for ${packageName}. Installed: ${installedVersion}, Available: ${availableVersions.join(', ')}`);\\n    }\\n\\n    return this.selectBestVersion(compatibleVersions);\\n  }\\n\\n  private areVersionsCompatible(version1: string, version2: string): boolean {\\n    try {\\n      const range1 = semver.major(version1);\\n      const range2 = semver.major(version2);\\n      \\n      return range1 === range2;\\n    } catch {\\n      return version1 === version2;\\n    }\\n  }\\n\\n  private isVersionCompatible(installedVersion?: string, availableVersions: string[] = []): boolean {\\n    if (!installedVersion || availableVersions.length === 0) {\\n      return true;\\n    }\\n\\n    return availableVersions.some(version => \\n      this.areVersionsCompatible(installedVersion, version)\\n    );\\n  }\\n\\n  private selectBestVersion(versions: string[]): string {\\n    try {\\n      return semver.rsort(versions)[0];\\n    } catch {\\n      return versions[0];\\n    }\\n  }\\n\\n  registerInstalledVersion(packageName: string, version: string): void {\\n    this.installedVersions.set(packageName, version);\\n  }\\n\\n  registerAvailableVersions(packageName: string, versions: string[]): void {\\n    this.availableVersions.set(packageName, versions);\\n  }\\n\\n  getInstalledVersion(packageName: string): string | undefined {\\n    return this.installedVersions.get(packageName);\\n  }\\n\\n  getAvailableVersions(packageName: string): string[] {\\n    return this.availableVersions.get(packageName) || [];\\n  }\\n\\n  validateVersionConstraint(packageName: string, constraint: string): boolean {\\n    const installedVersion = this.installedVersions.get(packageName);\\n    \\n    if (!installedVersion) {\\n      return false;\\n    }\\n\\n    try {\\n      return semver.satisfies(installedVersion, constraint);\\n    } catch {\\n      return installedVersion === constraint;\\n    }\\n  }\\n\\n  clear(): void {\\n    this.availableVersions.clear();\\n    this.installedVersions.clear();\\n  }\\n}\",\"import { Injectable } from '@angular/core';\\nimport { FederationManifest, ModuleInfo, VersionStrategy } from '../types/federation';\\nimport { VersionManager } from './version-manager';\\n\\n@Injectable({\\n  providedIn: 'root'\\n})\\nexport class ModuleLoader {\\n  private loadedModules = new Map<string, ModuleInfo>();\\n  private manifest: FederationManifest = {};\\n  private importMapElement?: HTMLScriptElement;\\n\\n  constructor(private versionManager: VersionManager) {}\\n\\n  async initialize(manifestPath?: string): Promise<void> {\\n    if (manifestPath) {\\n      this.manifest = await this.loadManifest(manifestPath);\\n    }\\n    \\n    await this.setupImportMaps();\\n  }\\n\\n  async loadRemoteModule<T = any>(remoteName: string, modulePath: string): Promise<T> {\\n    const moduleId = `${remoteName}${modulePath}`;\\n    \\n    if (this.loadedModules.has(moduleId)) {\\n      const moduleInfo = this.loadedModules.get(moduleId)!;\\n      if (moduleInfo.loaded) {\\n        return import(moduleInfo.url);\\n      }\\n    }\\n\\n    const remoteUrl = await this.resolveRemoteUrl(remoteName);\\n    const moduleUrl = await this.resolveModuleUrl(remoteUrl, modulePath);\\n    \\n    try {\\n      const module = await this.loadModule(moduleUrl);\\n      \\n      this.loadedModules.set(moduleId, {\\n        id: moduleId,\\n        name: remoteName,\\n        version: '1.0.0',\\n        url: moduleUrl,\\n        deps: [],\\n        loaded: true,\\n        singleton: false\\n      });\\n\\n      return module;\\n    } catch (error: any) {\\n      throw new Error(`Failed to load remote module ${remoteName}${modulePath}: ${error.message}`);\\n    }\\n  }\\n\\n  async loadSharedModule<T = any>(packageName: string, versionStrategy?: VersionStrategy): Promise<T> {\\n    const moduleInfo = this.loadedModules.get(packageName);\\n    \\n    if (moduleInfo?.singleton && moduleInfo.loaded) {\\n      return import(moduleInfo.url);\\n    }\\n\\n    const resolvedVersion = await this.versionManager.resolveVersion(packageName, versionStrategy);\\n    const moduleUrl = await this.resolveSharedModuleUrl(packageName, resolvedVersion);\\n    \\n    try {\\n      const module = await this.loadModule(moduleUrl);\\n      \\n      this.loadedModules.set(packageName, {\\n        id: packageName,\\n        name: packageName,\\n        version: resolvedVersion,\\n        url: moduleUrl,\\n        deps: [],\\n        loaded: true,\\n        singleton: true\\n      });\\n\\n      return module;\\n    } catch (error: any) {\\n      if (versionStrategy?.type === 'fallback' && versionStrategy.fallbackVersion) {\\n        return this.loadSharedModule(packageName, {\\n          type: 'exact',\\n        });\\n      }\\n      \\n      throw new Error(`Failed to load shared module ${packageName}: ${error.message}`);\\n    }\\n  }\\n\\n  private async loadManifest(manifestPath: string): Promise<FederationManifest> {\\n    try {\\n      const response = await fetch(manifestPath);\\n      if (!response.ok) {\\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\\n      }\\n      return await response.json();\\n    } catch (error: any) {\\n      console.warn(`[Native Federation] Failed to load manifest from ${manifestPath}:`, error.message);\\n      return {};\\n    }\\n  }\\n\\n  private async setupImportMaps(): Promise<void> {\\n    try {\\n      const importMapResponse = await fetch('./importmap.json');\\n      if (importMapResponse.ok) {\\n        const importMap = await importMapResponse.json();\\n        this.injectImportMap(importMap);\\n      }\\n    } catch (error: any) {\\n      console.warn('[Native Federation] Failed to load import map:', error.message);\\n    }\\n  }\\n\\n  private injectImportMap(importMap: any): void {\\n    if (this.importMapElement) {\\n      this.importMapElement.remove();\\n    }\\n\\n    this.importMapElement = document.createElement('script');\\n    this.importMapElement.type = 'importmap';\\n    this.importMapElement.textContent = JSON.stringify(importMap);\\n    \\n    document.head.appendChild(this.importMapElement);\\n  }\\n\\n  private async resolveRemoteUrl(remoteName: string): Promise<string> {\\n    if (this.manifest[remoteName]) {\\n      return this.manifest[remoteName];\\n    }\\n\\n    throw new Error(`Remote ${remoteName} not found in manifest`);\\n  }\\n\\n  private async resolveModuleUrl(remoteUrl: string, modulePath: string): Promise<string> {\\n    try {\\n      const response = await fetch(remoteUrl);\\n      if (!response.ok) {\\n        throw new Error(`Failed to fetch remote entry: HTTP ${response.status}`);\\n      }\\n      \\n      const remoteEntry = await response.json();\\n      \\n      if (!remoteEntry.metadata?.exposes?.[modulePath]) {\\n        throw new Error(`Module ${modulePath} not exposed by remote`);\\n      }\\n\\n      const baseUrl = new URL(remoteUrl).origin;\\n      const exposedPath = remoteEntry.metadata.exposes[modulePath];\\n      \\n      return new URL(exposedPath, baseUrl).href;\\n    } catch (error: any) {\\n      throw new Error(`Failed to resolve module URL: ${error.message}`);\\n    }\\n  }\\n\\n  private async resolveSharedModuleUrl(packageName: string, version: string): Promise<string> {\\n    const baseUrl = window.location.origin;\\n    return `${baseUrl}/node_modules/.cache/native-federation/esm-packages/${packageName}/index.mjs`;\\n  }\\n\\n  private async loadModule(url: string): Promise<any> {\\n    try {\\n      return await import(url);\\n    } catch (error: any) {\\n      throw new Error(`Module import failed: ${error.message}`);\\n    }\\n  }\\n\\n  getLoadedModules(): Map<string, ModuleInfo> {\\n    return new Map(this.loadedModules);\\n  }\\n\\n  async preloadModule(remoteName: string, modulePath: string): Promise<void> {\\n    const link = document.createElement('link');\\n    link.rel = 'modulepreload';\\n    link.href = await this.resolveModuleUrl(\\n      await this.resolveRemoteUrl(remoteName),\\n      modulePath\\n    );\\n    document.head.appendChild(link);\\n  }\\n\\n  clearCache(): void {\\n    this.loadedModules.clear();\\n    if (this.importMapElement) {\\n      this.importMapElement.remove();\\n      this.importMapElement = undefined;\\n    }\\n  }\\n}\",\"import { Injectable } from '@angular/core';\\nimport { ModuleLoader } from './module-loader';\\nimport { ModuleInfo, FederationManifest } from '../types/federation';\\n\\n@Injectable({\\n  providedIn: 'root'\\n})\\nexport class FederationRuntime {\\n  private initialized = false;\\n  private manifest: FederationManifest | null = null;\\n\\n  constructor(private moduleLoader: ModuleLoader) {}\\n\\n  async initialize(manifestPath?: string): Promise<void> {\\n    if (this.initialized) {\\n      console.warn('[Native Federation] Federation already initialized');\\n      return;\\n    }\\n\\n    try {\\n      await this.moduleLoader.initialize(manifestPath);\\n      this.initialized = true;\\n\\n      if (typeof window !== 'undefined') {\\n        (window as any).__nativeFederation = {\\n          loadRemoteModule: this.loadRemoteModule.bind(this),\\n          loadSharedModule: this.loadSharedModule.bind(this),\\n          preloadModule: this.preloadModule.bind(this),\\n          getLoadedModules: this.getLoadedModules.bind(this),\\n          clearCache: this.clearCache.bind(this)\\n        };\\n      }\\n\\n      console.log('[Native Federation] Federation initialized successfully');\\n    } catch (error: any) {\\n      console.error('[Native Federation] Failed to initialize federation:', error);\\n      throw error;\\n    }\\n  }\\n\\n  async loadRemoteModule<T = any>(remoteName: string, modulePath: string): Promise<T> {\\n    if (!this.initialized) {\\n      throw new Error('[Native Federation] Federation not initialized. Call initialize() first.');\\n    }\\n\\n    return this.moduleLoader.loadRemoteModule<T>(remoteName, modulePath);\\n  }\\n\\n  async loadSharedModule<T = any>(packageName: string): Promise<T> {\\n    if (!this.initialized) {\\n      throw new Error('[Native Federation] Federation not initialized. Call initialize() first.');\\n    }\\n\\n    return this.moduleLoader.loadSharedModule<T>(packageName);\\n  }\\n\\n  async preloadModule(remoteName: string, modulePath: string): Promise<void> {\\n    if (!this.initialized) {\\n      throw new Error('[Native Federation] Federation not initialized. Call initialize() first.');\\n    }\\n\\n    return this.moduleLoader.preloadModule(remoteName, modulePath);\\n  }\\n\\n  getLoadedModules() {\\n    if (!this.initialized) {\\n      return new Map();\\n    }\\n\\n    return this.moduleLoader.getLoadedModules();\\n  }\\n\\n  clearCache(): void {\\n    this.moduleLoader.clearCache();\\n  }\\n\\n  isInitialized(): boolean {\\n    return this.initialized;\\n  }\\n\\n  async reinitialize(manifestPath?: string): Promise<void> {\\n    this.moduleLoader.clearCache();\\n    this.initialized = false;\\n    await this.initialize(manifestPath);\\n  }\\n\\n  getFederationStatus() {\\n    return {\\n      initialized: this.initialized,\\n      loadedModulesCount: this.moduleLoader.getLoadedModules().size,\\n      hasModuleLoader: true\\n    };\\n  }\\n}\\n\\n// Export functions for backward compatibility\\nexport async function initFederation(manifestPath?: string): Promise<void> {\\n  // Deprecated - use FederationRuntime class instead\\n  console.warn('[Native Federation] initFederation() is deprecated. Use FederationRuntime class instead.');\\n}\\n\\nexport async function loadRemoteModule<T = any>(remoteName: string, modulePath: string): Promise<T> {\\n  // Deprecated - use FederationRuntime class instead\\n  throw new Error('[Native Federation] loadRemoteModule() is deprecated. Use FederationRuntime class instead.');\\n}\",\"import { Injectable, Optional } from '@angular/core';\\nimport { FederationManifest, ModuleInfo, VersionStrategy } from '../types/federation';\\nimport { VersionManager } from './version-manager';\\n\\n/**\\n * Server-side module loader for SSR environments\\n * Handles module federation during server-side rendering\\n */\\n@Injectable({\\n  providedIn: 'root'\\n})\\nexport class SSRModuleLoader {\\n  private loadedModules = new Map<string, ModuleInfo>();\\n  private manifest: FederationManifest = {};\\n  private moduleCache = new Map<string, any>();\\n  private manifestPath?: string;\\n  private ssrContext?: {\\n    manifestPath?: string;\\n    fetch?: typeof fetch;\\n    require?: any;\\n  };\\n  \\n  constructor(\\n    private versionManager: VersionManager,\\n    @Optional() ssrContext?: {\\n      manifestPath?: string;\\n      fetch?: typeof fetch;\\n      require?: any;\\n    }\\n  ) {\\n    this.manifestPath = ssrContext?.manifestPath;\\n    this.ssrContext = ssrContext;\\n  }\\n\\n  async initialize(): Promise<void> {\\n    if (this.manifestPath) {\\n      this.manifest = await this.loadManifest(this.manifestPath);\\n    }\\n  }\\n\\n  /**\\n   * Load remote module during SSR\\n   * Returns pre-rendered content and hydration instructions\\n   */\\n  async loadRemoteModule<T = any>(\\n    remoteName: string, \\n    modulePath: string\\n  ): Promise<{\\n    module: T;\\n    ssrContent?: string;\\n    hydrationData?: any;\\n  }> {\\n    const moduleId = `${remoteName}${modulePath}`;\\n    \\n    // Check cache first\\n    if (this.moduleCache.has(moduleId)) {\\n      return { module: this.moduleCache.get(moduleId) };\\n    }\\n\\n    try {\\n      // In SSR, we need to resolve module path differently\\n      const moduleUrl = await this.resolveSSRModuleUrl(remoteName, modulePath);\\n      const module = await this.loadSSRModule(moduleUrl);\\n      \\n      // Cache the module\\n      this.moduleCache.set(moduleId, module);\\n      \\n      this.loadedModules.set(moduleId, {\\n        id: moduleId,\\n        name: remoteName,\\n        version: '1.0.0',\\n        url: moduleUrl,\\n        deps: [],\\n        loaded: true,\\n        singleton: false\\n      });\\n\\n      // Extract SSR content if available\\n      let ssrContent: string | undefined;\\n      let hydrationData: any;\\n\\n      if (module.renderToString && typeof module.renderToString === 'function') {\\n        ssrContent = await module.renderToString();\\n      }\\n\\n      if (module.getHydrationData && typeof module.getHydrationData === 'function') {\\n        hydrationData = await module.getHydrationData();\\n      }\\n\\n      return { module, ssrContent, hydrationData };\\n    } catch (error: any) {\\n      // In SSR, we might want to return fallback content instead of throwing\\n      console.warn(`[SSR] Failed to load remote module ${remoteName}${modulePath}:`, error.message);\\n      \\n      return {\\n        module: this.createFallbackModule(remoteName, modulePath),\\n        ssrContent: `<!-- SSR: Failed to load ${remoteName}${modulePath} -->`,\\n        hydrationData: { fallback: true, remoteName, modulePath }\\n      };\\n    }\\n  }\\n\\n  /**\\n   * Load shared module during SSR\\n   */\\n  async loadSharedModule<T = any>(\\n    packageName: string, \\n    versionStrategy?: VersionStrategy\\n  ): Promise<T> {\\n    const moduleInfo = this.loadedModules.get(packageName);\\n    \\n    if (moduleInfo?.singleton && moduleInfo.loaded && this.moduleCache.has(packageName)) {\\n      return this.moduleCache.get(packageName);\\n    }\\n\\n    try {\\n      // In Node.js environment, we can use require\\n      const module = this.ssrContext?.require \\n        ? this.ssrContext.require(packageName)\\n        : await import(packageName);\\n      \\n      this.moduleCache.set(packageName, module);\\n      \\n      this.loadedModules.set(packageName, {\\n        id: packageName,\\n        name: packageName,\\n        version: '1.0.0', // We'd need to resolve this properly\\n        url: packageName,\\n        deps: [],\\n        loaded: true,\\n        singleton: true\\n      });\\n\\n      return module;\\n    } catch (error: any) {\\n      throw new Error(`Failed to load shared module ${packageName} in SSR: ${error.message}`);\\n    }\\n  }\\n\\n  /**\\n   * Generate hydration manifest for client-side\\n   */\\n  generateHydrationManifest(): {\\n    loadedModules: Array<{ id: string; name: string; url: string; hydrationData?: any }>;\\n    importMap: Record<string, string>;\\n  } {\\n    const loadedModules: Array<{ id: string; name: string; url: string; hydrationData?: any }> = [];\\n    \\n    this.loadedModules.forEach((moduleInfo) => {\\n      loadedModules.push({\\n        id: moduleInfo.id,\\n        name: moduleInfo.name,\\n        url: moduleInfo.url,\\n        hydrationData: (moduleInfo as any).hydrationData\\n      });\\n    });\\n\\n    return {\\n      loadedModules,\\n      importMap: this.generateImportMap()\\n    };\\n  }\\n\\n  private async loadManifest(manifestPath: string): Promise<FederationManifest> {\\n    try {\\n      const fetchFn = this.ssrContext?.fetch || fetch;\\n      const response = await fetchFn(manifestPath);\\n      \\n      if (!response.ok) {\\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\\n      }\\n      \\n      return await response.json();\\n    } catch (error: any) {\\n      console.warn(`[SSR] Failed to load manifest from ${manifestPath}:`, error.message);\\n      return {};\\n    }\\n  }\\n\\n  private async resolveSSRModuleUrl(remoteName: string, modulePath: string): Promise<string> {\\n    // In SSR, we might need to resolve to local file paths or URLs\\n    if (this.manifest[remoteName]) {\\n      const remoteUrl = this.manifest[remoteName];\\n      \\n      // Handle local file paths for SSR\\n      if (remoteUrl.startsWith('/') || remoteUrl.startsWith('./')) {\\n        return `${remoteUrl}${modulePath}`;\\n      }\\n      \\n      // Handle remote URLs\\n      return `${remoteUrl}${modulePath}`;\\n    }\\n\\n    throw new Error(`Remote ${remoteName} not found in SSR manifest`);\\n  }\\n\\n  private async loadSSRModule(url: string): Promise<any> {\\n    try {\\n      // In Node.js environment, handle different module loading strategies\\n      if (url.startsWith('http')) {\\n        // Remote module - might need special handling\\n        const fetchFn = this.ssrContext?.fetch || fetch;\\n        const response = await fetchFn(url);\\n        const moduleCode = await response.text();\\n        \\n        // In production SSR, you'd want to evaluate this safely\\n        // For now, we'll simulate a module structure\\n        return { default: null, __ssrModule: true };\\n      } else {\\n        // Local module\\n        return this.ssrContext?.require \\n          ? this.ssrContext.require(url)\\n          : await import(url);\\n      }\\n    } catch (error: any) {\\n      throw new Error(`SSR module import failed: ${error.message}`);\\n    }\\n  }\\n\\n  private createFallbackModule(remoteName: string, modulePath: string): any {\\n    return {\\n      default: null,\\n      __fallback: true,\\n      __remoteName: remoteName,\\n      __modulePath: modulePath,\\n      renderToString: () => `<!-- Fallback for ${remoteName}${modulePath} -->`,\\n      getHydrationData: () => ({ fallback: true })\\n    };\\n  }\\n\\n  private generateImportMap(): Record<string, string> {\\n    const importMap: Record<string, string> = {};\\n    \\n    this.loadedModules.forEach((moduleInfo) => {\\n      if (moduleInfo.name.startsWith('@') || !moduleInfo.name.includes('/')) {\\n        // Shared dependency\\n        importMap[moduleInfo.name] = moduleInfo.url;\\n      }\\n    });\\n\\n    return importMap;\\n  }\\n\\n  getLoadedModules(): Map<string, ModuleInfo> {\\n    return new Map(this.loadedModules);\\n  }\\n\\n  clearCache(): void {\\n    this.loadedModules.clear();\\n    this.moduleCache.clear();\\n  }\\n}\\n\\n/**\\n * SSR utilities for framework integration\\n */\\nexport class SSRFederationUtils {\\n  static injectHydrationScript(\\n    html: string, \\n    hydrationManifest: ReturnType<SSRModuleLoader['generateHydrationManifest']>\\n  ): string {\\n    const script = `\\n      <script type=\\\"module\\\">\\n        // Hydration data for Native Federation\\n        window.__NF_HYDRATION__ = ${JSON.stringify(hydrationManifest)};\\n        \\n        // Pre-populate module cache\\n        if (window.__NF_HYDRATION__.loadedModules) {\\n          window.__NF_LOADED_MODULES__ = new Map();\\n          window.__NF_HYDRATION__.loadedModules.forEach(mod => {\\n            window.__NF_LOADED_MODULES__.set(mod.id, mod);\\n          });\\n        }\\n      </script>\\n    `;\\n\\n    // Inject before closing head tag\\n    return html.replace('</head>', `${script}</head>`);\\n  }\\n\\n  static generatePreloadLinks(\\n    loadedModules: Array<{ id: string; name: string; url: string }>\\n  ): string {\\n    return loadedModules\\n      .map(mod => `<link rel=\\\"modulepreload\\\" href=\\\"${mod.url}\\\">`)\\n      .join('\\\\n');\\n  }\\n}\",\"import { Injectable } from '@angular/core';\\nimport { ModuleLoader } from './module-loader';\\nimport { FederationManifest } from '../types/federation';\\nimport { VersionManager } from './version-manager';\\n\\n/**\\n * Client-side hydration support for SSR\\n * Resumes federation state from server-rendered content\\n */\\n@Injectable({\\n  providedIn: 'root'\\n})\\nexport class HydrationClient extends ModuleLoader {\\n  private hydrationData?: any;\\n  private ssrModuleCache = new Map<string, any>();\\n\\n  constructor(versionManager: VersionManager) {\\n    super(versionManager);\\n  }\\n\\n  async initializeWithHydration(manifestPath?: string): Promise<void> {\\n    // Extract hydration data from SSR\\n    this.extractHydrationData();\\n    \\n    // Initialize base module loader\\n    await this.initialize(manifestPath);\\n    \\n    // Restore SSR module cache\\n    await this.restoreSSRModules();\\n  }\\n\\n  /**\\n   * Load remote module with hydration support\\n   * Checks SSR cache first, then falls back to normal loading\\n   */\\n  async loadRemoteModule<T = any>(remoteName: string, modulePath: string): Promise<T> {\\n    const moduleId = `${remoteName}${modulePath}`;\\n    \\n    // Check if module was loaded during SSR\\n    if (this.ssrModuleCache.has(moduleId)) {\\n      const cached = this.ssrModuleCache.get(moduleId);\\n      \\n      // If it's a fallback, try to load the real module\\n      if (cached.__fallback) {\\n        try {\\n          return await super.loadRemoteModule(remoteName, modulePath);\\n        } catch (error) {\\n          console.warn(`[Hydration] Failed to load real module, using fallback:`, error);\\n          return cached;\\n        }\\n      }\\n      \\n      return cached;\\n    }\\n    \\n    // Fall back to normal loading\\n    return super.loadRemoteModule(remoteName, modulePath);\\n  }\\n\\n  /**\\n   * Check if module was server-rendered\\n   */\\n  wasServerRendered(remoteName: string, modulePath: string): boolean {\\n    const moduleId = `${remoteName}${modulePath}`;\\n    return this.ssrModuleCache.has(moduleId);\\n  }\\n\\n  /**\\n   * Get hydration data for a specific module\\n   */\\n  getModuleHydrationData(remoteName: string, modulePath: string): any {\\n    const moduleId = `${remoteName}${modulePath}`;\\n    const cached = this.ssrModuleCache.get(moduleId);\\n    return cached?.hydrationData;\\n  }\\n\\n  private extractHydrationData(): void {\\n    // Extract hydration data injected by SSR\\n    const hydrationData = (window as any).__NF_HYDRATION__;\\n    const loadedModules = (window as any).__NF_LOADED_MODULES__;\\n    \\n    if (hydrationData) {\\n      this.hydrationData = hydrationData;\\n      \\n      // Restore import map if available\\n      if (hydrationData.importMap) {\\n        this.injectHydrationImportMap({ imports: hydrationData.importMap });\\n      }\\n    }\\n    \\n    if (loadedModules) {\\n      loadedModules.forEach((moduleInfo: any, moduleId: string) => {\\n        this.ssrModuleCache.set(moduleId, {\\n          ...moduleInfo,\\n          __fromSSR: true\\n        });\\n      });\\n    }\\n  }\\n\\n  private async restoreSSRModules(): Promise<void> {\\n    if (!this.hydrationData?.loadedModules) {\\n      return;\\n    }\\n\\n    // Process each module that was loaded during SSR\\n    for (const moduleInfo of this.hydrationData.loadedModules) {\\n      try {\\n        // For non-fallback modules, try to establish client-side reference\\n        if (!moduleInfo.hydrationData?.fallback) {\\n          const module = await import(moduleInfo.url);\\n          this.ssrModuleCache.set(moduleInfo.id, module);\\n        }\\n      } catch (error) {\\n        console.warn(`[Hydration] Could not restore module ${moduleInfo.id}:`, error);\\n      }\\n    }\\n  }\\n\\n  private injectHydrationImportMap(importMap: any): void {\\n    const existingScript = document.querySelector('script[type=\\\"importmap\\\"]');\\n    if (existingScript) {\\n      // Merge with existing import map\\n      const existing = JSON.parse(existingScript.textContent || '{}');\\n      const merged = {\\n        imports: {\\n          ...existing.imports,\\n          ...importMap.imports\\n        }\\n      };\\n      existingScript.textContent = JSON.stringify(merged);\\n    } else {\\n      // Create new import map\\n      const script = document.createElement('script');\\n      script.type = 'importmap';\\n      script.textContent = JSON.stringify(importMap);\\n      document.head.appendChild(script);\\n    }\\n  }\\n}\\n\\n/**\\n * Angular-specific hydration utilities\\n */\\nexport class AngularHydrationUtils {\\n  /**\\n   * Initialize Native Federation with Angular Universal hydration\\n   */\\n  static async initializeForAngularSSR(\\n    client: HydrationClient,\\n    manifestPath?: string\\n  ): Promise<HydrationClient> {\\n    await client.initializeWithHydration(manifestPath);\\n    \\n    // Wait for Angular hydration to complete before loading remote modules\\n    if ((window as any).ng && (window as any).ng.getInjector) {\\n      await this.waitForAngularHydration();\\n    }\\n    \\n    return client;\\n  }\\n\\n  /**\\n   * Wait for Angular hydration to complete\\n   */\\n  private static async waitForAngularHydration(): Promise<void> {\\n    return new Promise((resolve) => {\\n      const checkHydration = () => {\\n        const appRef = (window as any).ng?.getInjector?.()?.get?.('ApplicationRef');\\n        if (appRef && appRef.isStable) {\\n          appRef.isStable.subscribe((stable: boolean) => {\\n            if (stable) {\\n              resolve();\\n            }\\n          });\\n        } else {\\n          // Fallback: wait a bit and try again\\n          setTimeout(checkHydration, 100);\\n        }\\n      };\\n      \\n      checkHydration();\\n    });\\n  }\\n\\n  /**\\n   * Create Angular component wrapper that handles SSR/hydration\\n   */\\n  static createSSRComponent<T>(\\n    loader: () => Promise<{ default: T }>,\\n    fallbackTemplate: string = '<div>Loading...</div>'\\n  ) {\\n    return {\\n      template: fallbackTemplate,\\n      async ngOnInit() {\\n        try {\\n          const { default: Component } = await loader();\\n          // Dynamic component loading logic would go here\\n          // This would integrate with Angular's ViewContainerRef\\n        } catch (error) {\\n          console.error('Failed to load federated component:', error);\\n        }\\n      }\\n    };\\n  }\\n}\\n\\n/**\\n * Universal federation runtime that works in both SSR and client\\n */\\n@Injectable({\\n  providedIn: 'root'\\n})\\nexport class UniversalFederationRuntime {\\n  private isSSR: boolean;\\n\\n  constructor(private hydrationClient: HydrationClient) {\\n    this.isSSR = typeof window === 'undefined';\\n  }\\n\\n  async initialize(manifestPath?: string): Promise<void> {\\n    if (this.isSSR) {\\n      // SSR initialization will be handled separately\\n      return;\\n    }\\n    \\n    await this.hydrationClient.initializeWithHydration(manifestPath);\\n  }\\n\\n  async loadRemoteModule<T = any>(remoteName: string, modulePath: string): Promise<T> {\\n    if (this.isSSR) {\\n      throw new Error('SSR module loading should use SSRModuleLoader directly');\\n    }\\n    \\n    return this.hydrationClient.loadRemoteModule(remoteName, modulePath);\\n  }\\n\\n  async loadSharedModule<T = any>(packageName: string): Promise<T> {\\n    return this.hydrationClient.loadSharedModule(packageName);\\n  }\\n\\n  wasServerRendered(remoteName: string, modulePath: string): boolean {\\n    if (this.isSSR) {\\n      return false;\\n    }\\n    \\n    return this.hydrationClient.wasServerRendered(remoteName, modulePath);\\n  }\\n}\",\"import { Injectable } from '@angular/core';\\nimport { FederationRuntime } from '../runtime/federation-runtime';\\nimport { ModuleLoader } from '../runtime/module-loader';\\n\\n@Injectable({\\n  providedIn: 'root'\\n})\\nexport class NativeFederationService {\\n  constructor(\\n    private runtime: FederationRuntime,\\n    private moduleLoader: ModuleLoader\\n  ) {}\\n\\n  /**\\n   * Initialize the federation runtime with a manifest\\n   */\\n  async initialize(manifestUrl: string): Promise<void> {\\n    await this.runtime.initialize(manifestUrl);\\n  }\\n\\n  /**\\n   * Load a remote module dynamically\\n   */\\n  async loadRemoteModule<T = any>(remoteName: string, modulePath: string): Promise<T> {\\n    return this.moduleLoader.loadRemoteModule<T>(remoteName, modulePath);\\n  }\\n\\n  /**\\n   * Check if a module is loaded\\n   */\\n  isModuleLoaded(remoteName: string, modulePath: string): boolean {\\n    const moduleId = `${remoteName}${modulePath}`;\\n    return this.moduleLoader.getLoadedModules().has(moduleId);\\n  }\\n\\n  /**\\n   * Preload a remote module\\n   */\\n  async preloadModule(remoteName: string, modulePath: string): Promise<void> {\\n    await this.moduleLoader.preloadModule(remoteName, modulePath);\\n  }\\n\\n  /**\\n   * Get the runtime instance for advanced usage\\n   */\\n  getRuntime(): FederationRuntime {\\n    return this.runtime;\\n  }\\n\\n  /**\\n   * Get the module loader instance for advanced usage\\n   */\\n  getModuleLoader(): ModuleLoader {\\n    return this.moduleLoader;\\n  }\\n}\",\"import {\\n  Directive,\\n  Input,\\n  ViewContainerRef,\\n  ComponentRef,\\n  OnInit,\\n  OnDestroy,\\n  ChangeDetectorRef,\\n  TemplateRef,\\n  EmbeddedViewRef,\\n  Injector,\\n  Type\\n} from '@angular/core';\\nimport { NativeFederationService } from '../native-federation.service';\\n\\n@Directive({\\n  selector: '[nfLoadComponent]'\\n})\\nexport class LoadFederatedComponentDirective implements OnInit, OnDestroy {\\n  @Input('nfLoadComponent') componentInfo!: string;\\n  @Input('nfFallback') fallbackTemplate?: TemplateRef<any>;\\n  @Input('nfLoadingTemplate') loadingTemplate?: TemplateRef<any>;\\n  @Input('nfErrorTemplate') errorTemplate?: TemplateRef<any>;\\n  @Input('nfInputs') inputs?: { [key: string]: any };\\n\\n  private componentRef?: ComponentRef<any>;\\n  private currentView?: EmbeddedViewRef<any>;\\n  private isLoading = false;\\n\\n  constructor(\\n    private viewContainer: ViewContainerRef,\\n    private federationService: NativeFederationService,\\n    private cdr: ChangeDetectorRef,\\n    private injector: Injector\\n  ) {}\\n\\n  async ngOnInit() {\\n    await this.loadComponent();\\n  }\\n\\n  ngOnDestroy() {\\n    this.cleanup();\\n  }\\n\\n  private async loadComponent() {\\n    if (!this.componentInfo) {\\n      console.warn('[LoadFederatedComponentDirective] No component info provided');\\n      return;\\n    }\\n\\n    // Parse component info (format: \\\"remoteName/modulePath\\\")\\n    const [remoteName, modulePath] = this.componentInfo.split('/');\\n    if (!remoteName || !modulePath) {\\n      console.error('[LoadFederatedComponentDirective] Invalid component info format. Use \\\"remoteName/modulePath\\\"');\\n      this.showErrorView('Invalid component format');\\n      return;\\n    }\\n\\n    try {\\n      this.isLoading = true;\\n      this.showLoadingView();\\n\\n      // Load the remote module\\n      const module = await this.federationService.loadRemoteModule(remoteName, `./${modulePath}`);\\n      \\n      // Get the component from the module\\n      const ComponentClass = this.getComponentFromModule(module);\\n      if (!ComponentClass) {\\n        throw new Error(`Component not found in module ${remoteName}/${modulePath}`);\\n      }\\n\\n      // Create and insert the component\\n      await this.createComponent(ComponentClass);\\n\\n    } catch (error) {\\n      console.error('[LoadFederatedComponentDirective] Failed to load component:', error);\\n      this.showErrorView(error instanceof Error ? error.message : 'Unknown error');\\n    } finally {\\n      this.isLoading = false;\\n    }\\n  }\\n\\n  private getComponentFromModule(module: any): Type<any> | null {\\n    // Try different common export patterns\\n    if (module.default && typeof module.default === 'function') {\\n      return module.default;\\n    }\\n    \\n    if (module.Component && typeof module.Component === 'function') {\\n      return module.Component;\\n    }\\n\\n    // Look for the first function export (likely a component)\\n    for (const key of Object.keys(module)) {\\n      if (typeof module[key] === 'function' && key !== 'default') {\\n        return module[key];\\n      }\\n    }\\n\\n    return null;\\n  }\\n\\n  private async createComponent(ComponentClass: Type<any>) {\\n    this.cleanup();\\n\\n    try {\\n      // Create the component\\n      this.componentRef = this.viewContainer.createComponent(ComponentClass, {\\n        injector: this.injector\\n      });\\n\\n      // Set inputs if provided\\n      if (this.inputs) {\\n        Object.keys(this.inputs).forEach(key => {\\n          if (this.componentRef?.instance[key] !== undefined) {\\n            this.componentRef.instance[key] = this.inputs![key];\\n          }\\n        });\\n      }\\n\\n      // Trigger change detection\\n      this.componentRef.changeDetectorRef.detectChanges();\\n      this.cdr.detectChanges();\\n\\n    } catch (error) {\\n      console.error('[LoadFederatedComponentDirective] Failed to create component:', error);\\n      throw error;\\n    }\\n  }\\n\\n  private showLoadingView() {\\n    this.cleanup();\\n    \\n    if (this.loadingTemplate) {\\n      this.currentView = this.viewContainer.createEmbeddedView(this.loadingTemplate);\\n    } else {\\n      // Create default loading view\\n      this.createDefaultLoadingView();\\n    }\\n  }\\n\\n  private showErrorView(error: string) {\\n    this.cleanup();\\n    \\n    if (this.errorTemplate) {\\n      this.currentView = this.viewContainer.createEmbeddedView(this.errorTemplate, { error });\\n    } else if (this.fallbackTemplate) {\\n      this.currentView = this.viewContainer.createEmbeddedView(this.fallbackTemplate);\\n    } else {\\n      // Create default error view\\n      this.createDefaultErrorView(error);\\n    }\\n  }\\n\\n  private createDefaultLoadingView() {\\n    const div = document.createElement('div');\\n    div.style.padding = '20px';\\n    div.style.textAlign = 'center';\\n    div.style.color = '#666';\\n    div.innerHTML = '⏳ Loading federated component...';\\n    \\n    const elementRef = { nativeElement: div };\\n    this.currentView = this.viewContainer.createEmbeddedView(\\n      { createEmbeddedView: () => ({ rootNodes: [div] }) } as any\\n    );\\n  }\\n\\n  private createDefaultErrorView(error: string) {\\n    const div = document.createElement('div');\\n    div.style.padding = '20px';\\n    div.style.border = '1px solid #f5c6cb';\\n    div.style.backgroundColor = '#f8d7da';\\n    div.style.color = '#721c24';\\n    div.style.borderRadius = '4px';\\n    div.innerHTML = `\\n      <strong>❌ Failed to load federated component</strong><br>\\n      <small>${this.componentInfo}</small><br>\\n      <em>${error}</em>\\n    `;\\n    \\n    this.currentView = this.viewContainer.createEmbeddedView(\\n      { createEmbeddedView: () => ({ rootNodes: [div] }) } as any\\n    );\\n  }\\n\\n  private cleanup() {\\n    if (this.componentRef) {\\n      this.componentRef.destroy();\\n      this.componentRef = undefined;\\n    }\\n    \\n    if (this.currentView) {\\n      this.currentView.destroy();\\n      this.currentView = undefined;\\n    }\\n    \\n    this.viewContainer.clear();\\n  }\\n}\",\"import { NgModule } from '@angular/core';\\nimport { CommonModule } from '@angular/common';\\nimport { NativeFederationService } from './native-federation.service';\\nimport { LoadFederatedComponentDirective } from './directives/load-federated-component.directive';\\n\\n@NgModule({\\n  declarations: [\\n    LoadFederatedComponentDirective\\n  ],\\n  imports: [\\n    CommonModule\\n  ],\\n  providers: [\\n    NativeFederationService\\n  ],\\n  exports: [\\n    LoadFederatedComponentDirective\\n  ]\\n})\\nexport class NativeFederationModule { }\",\"import { inject, Injectable, PLATFORM_ID } from '@angular/core';\\nimport { isPlatformBrowser, isPlatformServer } from '@angular/common';\\nimport { makeStateKey, StateKey, TransferState } from '@angular/core';\\nimport { SSRModuleLoader, SSRFederationUtils } from '../runtime/ssr-module-loader';\\nimport { HydrationClient, AngularHydrationUtils } from '../runtime/hydration-client';\\n\\n/**\\n * Angular service for Native Federation SSR support\\n */\\n@Injectable({\\n  providedIn: 'root'\\n})\\nexport class SSRFederationService {\\n  private platformId = inject(PLATFORM_ID);\\n  private transferState = inject(TransferState);\\n  private ssrLoader = inject(SSRModuleLoader);\\n  private hydrationClient = inject(HydrationClient);\\n  private clientLoader?: HydrationClient;\\n\\n  private readonly FEDERATION_STATE_KEY: StateKey<any> = makeStateKey('NF_SSR_STATE');\\n\\n  constructor() {\\n    if (isPlatformServer(this.platformId)) {\\n      this.initializeSSR();\\n    } else {\\n      this.initializeClient();\\n    }\\n  }\\n\\n  /**\\n   * Load remote module with SSR/hydration support\\n   */\\n  async loadRemoteModule<T = any>(\\n    remoteName: string, \\n    modulePath: string\\n  ): Promise<T> {\\n    if (isPlatformServer(this.platformId)) {\\n      return this.loadRemoteModuleSSR(remoteName, modulePath);\\n    } else {\\n      return this.loadRemoteModuleClient(remoteName, modulePath);\\n    }\\n  }\\n\\n  /**\\n   * Load shared module with SSR/hydration support\\n   */\\n  async loadSharedModule<T = any>(packageName: string): Promise<T> {\\n    if (isPlatformServer(this.platformId)) {\\n      return this.ssrLoader!.loadSharedModule(packageName);\\n    } else {\\n      return this.clientLoader!.loadSharedModule(packageName);\\n    }\\n  }\\n\\n  /**\\n   * Check if module was server-rendered\\n   */\\n  wasServerRendered(remoteName: string, modulePath: string): boolean {\\n    if (isPlatformBrowser(this.platformId)) {\\n      return this.clientLoader?.wasServerRendered(remoteName, modulePath) || false;\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Get SSR content for a remote module (server-side only)\\n   */\\n  async getSSRContent(remoteName: string, modulePath: string): Promise<string | null> {\\n    if (isPlatformServer(this.platformId)) {\\n      try {\\n        const result = await this.ssrLoader!.loadRemoteModule(remoteName, modulePath);\\n        return result.ssrContent || null;\\n      } catch (error) {\\n        console.warn(`[SSR] Failed to get SSR content for ${remoteName}${modulePath}:`, error);\\n        return null;\\n      }\\n    }\\n    return null;\\n  }\\n\\n  private async initializeSSR(): Promise<void> {\\n    // SSRModuleLoader is injected via DI\\n    await this.ssrLoader.initialize();\\n  }\\n\\n  private async initializeClient(): Promise<void> {\\n    // HydrationClient is injected via DI\\n    this.clientLoader = await AngularHydrationUtils.initializeForAngularSSR(this.hydrationClient, './federation.manifest.json');\\n    \\n    // Restore SSR state from TransferState\\n    const ssrState = this.transferState.get(this.FEDERATION_STATE_KEY, null);\\n    if (ssrState) {\\n      // Process any SSR state if needed\\n      console.log('[NF] Restored SSR state:', ssrState);\\n    }\\n  }\\n\\n  private async loadRemoteModuleSSR<T = any>(\\n    remoteName: string, \\n    modulePath: string\\n  ): Promise<T> {\\n    const result = await this.ssrLoader!.loadRemoteModule(remoteName, modulePath);\\n    \\n    // Store hydration data in TransferState for client\\n    if (result.hydrationData) {\\n      const currentState = this.transferState.get(this.FEDERATION_STATE_KEY, {});\\n      currentState[`${remoteName}${modulePath}`] = result.hydrationData;\\n      this.transferState.set(this.FEDERATION_STATE_KEY, currentState);\\n    }\\n    \\n    return result.module;\\n  }\\n\\n  private async loadRemoteModuleClient<T = any>(\\n    remoteName: string, \\n    modulePath: string\\n  ): Promise<T> {\\n    return this.clientLoader!.loadRemoteModule(remoteName, modulePath);\\n  }\\n}\\n\\n/**\\n * Angular directive for loading federated components with SSR support\\n */\\nimport { Directive, Input, ViewContainerRef, OnInit, OnDestroy } from '@angular/core';\\n\\n@Directive({\\n  selector: '[nfLoadComponent]',\\n  standalone: true\\n})\\nexport class LoadFederatedComponentDirective implements OnInit, OnDestroy {\\n  @Input() nfLoadComponent!: string; // Format: \\\"remoteName/modulePath\\\"\\n  @Input() nfFallback?: string;\\n\\n  private federationService = inject(SSRFederationService);\\n  private viewContainer = inject(ViewContainerRef);\\n\\n  async ngOnInit() {\\n    if (!this.nfLoadComponent) {\\n      return;\\n    }\\n\\n    const [remoteName, ...modulePathParts] = this.nfLoadComponent.split('/');\\n    const modulePath = './' + modulePathParts.join('/');\\n\\n    try {\\n      // Check if component was server-rendered\\n      if ((this.federationService as any).wasServerRendered?.(remoteName, modulePath)) {\\n        console.log(`[NF] Component ${this.nfLoadComponent} was server-rendered, hydrating...`);\\n      }\\n\\n      const module = await (this.federationService as any).loadRemoteModule(remoteName, modulePath);\\n      \\n      // Assume the module exports a component as default\\n      const component = module.default || module;\\n      \\n      if (component) {\\n        this.viewContainer.createComponent(component);\\n      } else {\\n        this.renderFallback();\\n      }\\n    } catch (error) {\\n      console.error(`[NF] Failed to load component ${this.nfLoadComponent}:`, error);\\n      this.renderFallback();\\n    }\\n  }\\n\\n  ngOnDestroy() {\\n    this.viewContainer.clear();\\n  }\\n\\n  private renderFallback() {\\n    if (this.nfFallback) {\\n      // Render fallback template\\n      this.viewContainer.clear();\\n      // You would implement fallback rendering logic here\\n      console.log(`[NF] Rendering fallback for ${this.nfLoadComponent}: ${this.nfFallback}`);\\n    }\\n  }\\n}\\n\\n/**\\n * Angular helper functions for SSR setup\\n */\\nexport class AngularSSRHelpers {\\n  /**\\n   * Setup SSR module loader in Angular Universal\\n   */\\n  static setupSSRLoader(versionManager: any, manifestPath?: string): SSRModuleLoader {\\n    const loader = new SSRModuleLoader(versionManager, {\\n      manifestPath\\n    });\\n    return loader;\\n  }\\n\\n  /**\\n   * Generate hydration script for Angular Universal\\n   */\\n  static generateHydrationScript(ssrLoader: SSRModuleLoader): string {\\n    const hydrationManifest = ssrLoader.generateHydrationManifest();\\n    return SSRFederationUtils.injectHydrationScript('', hydrationManifest);\\n  }\\n\\n  /**\\n   * Create Angular Universal render function with federation support\\n   */\\n  static createUniversalRenderFunction(\\n    originalRenderFn: Function,\\n    manifestPath?: string\\n  ) {\\n    return async function renderWithFederation(options: any) {\\n      // Initialize SSR loader\\n      // TODO: versionManager should be provided via DI\\n      const ssrLoader = AngularSSRHelpers.setupSSRLoader(null as any, manifestPath);\\n      \\n      // Add to options so components can access it\\n      options.ssrLoader = ssrLoader;\\n      \\n      // Call original render function\\n      const result = await originalRenderFn(options);\\n      \\n      // Inject hydration script\\n      if (typeof result === 'string') {\\n        const hydrationScript = AngularSSRHelpers.generateHydrationScript(ssrLoader);\\n        return SSRFederationUtils.injectHydrationScript(result, \\n          ssrLoader.generateHydrationManifest());\\n      }\\n      \\n      return result;\\n    };\\n  }\\n}\\n\\n/**\\n * Provider for Angular app configuration\\n */\\nexport function createSSRFederationProviders(manifestPath?: string) {\\n  return [\\n    SSRFederationService,\\n    {\\n      provide: 'NF_MANIFEST_PATH',\\n      useValue: manifestPath || './federation.manifest.json'\\n    }\\n  ];\\n}\\n\\n/**\\n * Angular Universal Federation Provider\\n */\\nexport const AngularUniversalFederationProvider = {\\n  provide: SSRFederationService,\\n  useClass: SSRFederationService\\n};\",\"/*\\n * Public API Surface of @native-federation/core\\n */\\n\\n// Runtime (Browser-compatible)\\nexport * from './lib/runtime/federation-runtime';\\nexport * from './lib/runtime/module-loader';\\nexport * from './lib/runtime/ssr-module-loader';\\nexport * from './lib/runtime/hydration-client';\\nexport * from './lib/runtime/version-manager';\\n\\n// Angular Integration\\nexport * from './lib/angular/native-federation.module';\\nexport * from './lib/angular/native-federation.service';\\nexport * from './lib/angular/directives/load-federated-component.directive';\\nexport { \\n  SSRFederationService,\\n  AngularUniversalFederationProvider,\\n  createSSRFederationProviders\\n} from './lib/angular/ssr-integration';\\n\\n// Types\\nexport * from './lib/types/federation';\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[\"i1.VersionManager\",\"i1.ModuleLoader\",\"i1.FederationRuntime\",\"i2.ModuleLoader\",\"i1.NativeFederationService\",\"LoadFederatedComponentDirective\"],\"mappings\":\"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\"}","type":"asset"}]}